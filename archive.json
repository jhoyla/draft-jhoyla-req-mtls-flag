{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-06-12T00:30:23.976923+00:00",
  "repo": "jhoyla/draft-jhoyla-req-mtls-flag",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOKjmGVs6ufiKv",
      "title": "Should this be \"request-mtls\" or should this be \"request-bot-auth\"?",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/3",
      "state": "OPEN",
      "author": "bob-beck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"This enables a number of use cases, for example allowing bots to authenticate themselves when mixed in with general traffic.\"\n\nAfter some discussion with you and others seems to indicate that there may be an opinion that \"browsers shouldn't do this\"\n\nIf the intention is truly for \"bot-auth\" should this really be about only bot-auth - and perhaps include being opinionated about what the bot-auth is to perhaps simplify the resulting pki for this? (maybe not just any old X.509 certificate blob with path building etc,  but perhaps something more limited or even a raw public key to encourage dedicated trust stores for this purpose?)\n\nOr is the intention here to be a generic \"it's safe to send me a certificate request\" that browsers/clients/things-not-bots could possibly start using for certain things - and leaving \"bot-auth\" to have to disambiguate the cases (i.e. what trust store to use) on the server by other means if both are in use. \n",
      "createdAt": "2025-03-18T07:49:25Z",
      "updatedAt": "2025-06-10T17:39:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "So after discussions with various people, there seems to be a strong push for this to be \"bot-auth\" only. That's probably ok, as long as we're not too specific about what \"bot\" means. \n\nI don't like the idea of raw public keys, because it requires us to reinvent a number of wheels, e.g. expiry, rotation, delegation, binding names to keys, provisioning, etc. Restricting the certs to SPIFFE certs holds a certain appeal to me, but I'm not sure what others think. @cjpatton?",
          "createdAt": "2025-06-09T17:10:20Z",
          "updatedAt": "2025-06-09T17:10:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't have an especially strong opinion here. We certainly should try to keep the PKI simple, but I don't see a reason to go as far as using raw public keys rather than X.509. Rather we might try to be prescriptive about how the server selects trust anchors when the flag is negotiated.",
          "createdAt": "2025-06-09T17:46:33Z",
          "updatedAt": "2025-06-09T17:46:33Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "I await the chatgpt generated bike sheds for the definition of a bot, but to me at least at the moment for this draft I think it means \"There is no meatspace entity sitting at a keyboard causing this connection to be made with interactive expectations\".  \n\"I am not a web browser\". ",
          "createdAt": "2025-06-09T17:52:44Z",
          "updatedAt": "2025-06-09T17:52:44Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "I agree with keeping it simple, and I don't think bringing in extra opinions in this draft about what form the certificate will take will help that unless we can't solve an issue any other way.   \n\n",
          "createdAt": "2025-06-09T17:54:49Z",
          "updatedAt": "2025-06-09T17:54:49Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "Assuming a server is responding with an echo'ed flag in a certificate request message, the server can either choose to include the CA extension (or possibly in the future TLS Trust Anchor IDs) to tell the client what it wants, or not include it and the client today gets to \"guess\" based on \"ecosystem expectation\" like any other time one end of a TLS connection gets to send a cert without being given a hint. \n\nIf the client doesn't want to \"guess\" it's of course free to send the empty certificate and the server decides if it wants to continue. \n\nIs there a problem with that model here? if not we don't need to say anything. ",
          "createdAt": "2025-06-09T18:05:44Z",
          "updatedAt": "2025-06-09T18:07:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The only problem I can see is if the server conflates the bot PKI with the existing PKI it currently uses for the client authentication, e.g., by allowing a cross-sign of a bot cert by the exiting PKI or vise versa. But I don't know that there's a protocol change that could avoid that.",
          "createdAt": "2025-06-09T18:20:59Z",
          "updatedAt": "2025-06-09T18:22:25Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "But of course it might do that intentionally.  \n\nSo, is this scenario a valid use case or not: \n\nI am Bob. I use a client cert signed by a root from honestachmed.ca to authenticate myself for access to POST things to several API's on the site. so /api/foo, /api/bar, and /api/global-thermonuclear-war.\n\nI also write/use agentic bots to do things on my behalf. they do things as me, with my cert. \n\nThe server differentiates on the client sending the \"I am a bot\" extension to only grant bob as a bot access to api/foo and api/bar, and not api/global-thermonuclear-war. \n\nNow, I'm not strictly saying this is a good idea or a bad idea. but it's something someone might do. ",
          "createdAt": "2025-06-09T18:41:39Z",
          "updatedAt": "2025-06-09T18:41:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this example shows that \"human-in-the-loop\" is not the right way to think of \"bot\". What matters to us I think is what access is granted to the client, not whether the client is human or a bot acting on behalf of a human. See https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/6#issuecomment-2956638120.",
          "createdAt": "2025-06-09T18:50:56Z",
          "updatedAt": "2025-06-09T18:50:56Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "So @thibmeu has an interesting definition of a bot for the purposes of HTTP Sigs, which is that \"a bot is something with no expectation of privacy\". I actually really like this framing, because it makes it clear when you should and shouldn't use this, or rather, which identities go in the certificate. If you are an agent acting for some user (I've been using the word [principal](https://en.wikipedia.org/wiki/Principal_(commercial_law)) to capture the idea of the person directing the bot just because I can't think of a better one, suggestions extremely welcome), then whilst the user might have some expectation of privacy, the agent (the controller of the private key) here does not.",
          "createdAt": "2025-06-10T14:43:31Z",
          "updatedAt": "2025-06-10T14:43:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't believe that definition is sufficient for our purposes because it doesn't fully account for how we handle requests from humans versus bots. Privacy is just one facet of this.",
          "createdAt": "2025-06-10T14:54:46Z",
          "updatedAt": "2025-06-10T14:55:44Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "I'm not convinced that there is any useful definition of a bot beyond defining it as \"not human\". Maybe just privacy isn't sufficient, but I do like framing in terms of \"what rights do humans have that we don't need to honour here\".",
          "createdAt": "2025-06-10T15:31:22Z",
          "updatedAt": "2025-06-10T15:31:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "That's kind of my point: we don't _need_ to define \"bot\". All we need to define is how we handle traffic from a client that identifies themself as a bot.",
          "createdAt": "2025-06-10T15:40:25Z",
          "updatedAt": "2025-06-10T15:40:25Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "I agree in that focusing on a definition of a bot is probably tangential, the desired goal is to define what the extension is supposed to be used for and write a useful security concerns section to guide implementors on what they should and should not do with it. \n\n",
          "createdAt": "2025-06-10T17:39:11Z",
          "updatedAt": "2025-06-10T17:39:11Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOKjmGVs64-a8l",
      "title": "Security Considerations: Address risk of making authentication logic more complex",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/6",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is interesting because even if the flag on its own has no security impact, the use case we intend to support here -- web bot auth -- certainly does. Namely, we have to override the logic the server uses to decide whether to send a CertificateRequest, how to select a trust anchor to validate the Certificate, and how to handle application data. We don't want to authorize HTTP requests from a crawler that would otherwise require a different client identity.\r\n\r\nGiven the WG feedback so far, I think we'll need to discuss this here. If you'd rather do it in a separate PR, then feel free to just leave a TODO here.\r\n\r\n_Originally posted by @cjpatton in https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/4#discussion_r2114816776_\r\n            ",
      "createdAt": "2025-05-30T14:15:26Z",
      "updatedAt": "2025-06-11T18:49:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: The scope of this issue might change if (1) we decide to scope the draft to \"request bot auth\" (#3) and (2) we decide the draft itself should manage the complexity of authentication logic, e.g., by partitioning the set of trust anchors and spelling out requirements for CAs.",
          "createdAt": "2025-05-30T16:02:44Z",
          "updatedAt": "2025-05-30T16:02:44Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "I'm not sure it needs to manage partitioning a trust anchor set as is.  Assuming the client sends the extension and it \"means whatever we decide it means\" and the server replies with a certificate request message echoing the extension, The server is certainly free to tell the client what CA it expects for this via the CA extension, which would be the normal way servers do this today.  Chris do you see a need to change that? \n\nNow, of course, this could then end up with something the client can't satisfy, at which point we are back to sending an empty certificate reply, and the server gets to decide if it wants to proceed or not. \n",
          "createdAt": "2025-06-09T17:48:28Z",
          "updatedAt": "2025-06-09T17:48:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not sure it needs to manage partitioning a trust anchor set as is. Assuming the client sends the extension and it \"means whatever we decide it means\" and the server replies with a certificate request message echoing the extension, The server is certainly free to tell the client what CA it expects for this via the CA extension, which would be the normal way servers do this today. Chris do you see a need to change that?\n\nI don't think we need to change this logic, no. My concern has more to do with how the certificate is used to handle application data.\n\nSuppose for instance that the server is configured to always request a certificate so that, if the client presents a valid certificate, it gets access to certain HTTP resources (like `POST /admin/api` or something). If the server grants access if _any_ certificate is presented, then it might inadvertently grant access to a bot as well.  The server needs to modify its logic to grant access only if the right certificate is used.\n\nI don't think we necessarily need to deal with this at the protocol level, but it's worthy of a security consideration that helps implementers do the right thing.\n\n> Now, of course, this could then end up with something the client can't satisfy, at which point we are back to sending an empty certificate reply, and the server gets to decide if it wants to proceed or not.\n\nThat sounds right to me. Have you had a chance to look at the text since @jhoyla's last PR (#4)? I think that's more or less what the draft says now. Do you think this is the right client behavior?",
          "createdAt": "2025-06-09T18:14:24Z",
          "updatedAt": "2025-06-09T18:14:24Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "\"If the server grants access if any certificate is presented, then it might inadvertently grant access to a bot as well. The server needs to modify its logic to grant access only if the right certificate is used.\"\n\nI think this comes down to defining what \"bot auth\" means, and with that, writing an appropriate security considerations section indicating that implementors need to ensure that access is only granted to things appropriate for bot auth. This can also of course, include restricting things that would otherwise be accessible without a certificate if I was not a bot ;) \n\n",
          "createdAt": "2025-06-09T18:26:44Z",
          "updatedAt": "2025-06-09T18:27:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. To me the definition of bot auth is most relevant to (or even _only relevant to_?) how we treat application data. Namely, we treat the TLS client as if it were an unauthenticated TLS client, except the server might bypass some security measure applied to unauthenticated TLS clients. For instance, we want to rate limit clients _pretending_ to be GoogleBot, but not GoogleBot itself.\n\n@jhoyla has been thinking about this for a lot longer than me and perhaps has a more precise definition in mind!",
          "createdAt": "2025-06-09T18:44:39Z",
          "updatedAt": "2025-06-09T18:44:39Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "I don't think \"bypass\" is the correct framing here. They are going down an alternative, and IMO _stricter_ path. \n\nBut overall, I think we should say in the security considerations something along the lines of \"If the bot auth flag is accepted then the server should verify the certificate against an appropriate set of trust anchors, which may or may not be disjoint to the set of trust anchors it uses when the flag is ignored or rejected. Failure to do so may result in authenticating a bot when they are not intended to be authenticated.\"",
          "createdAt": "2025-06-10T15:27:48Z",
          "updatedAt": "2025-06-10T15:27:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think \"bypass\" is the correct framing here. They are going down an alternative, and IMO _stricter_ path.\n\nAgreed.\n\n> But overall, I think we should say in the security considerations something along the lines of \"If the bot auth flag is accepted then the server should verify the certificate against an appropriate set of trust anchors, which may or may not be disjoint to the set of trust anchors it uses when the flag is ignored or rejected. Failure to do so may result in authenticating a bot when they are not intended to be authenticated.\"\n\nI'm mostly on board with this, but I would want to recommend against mixing trust anchors (\"may not be disjoint\").",
          "createdAt": "2025-06-10T15:43:37Z",
          "updatedAt": "2025-06-10T15:43:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@bob-beck would you mind taking a look at the changes to Security Considerations in this PR: https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/15",
          "createdAt": "2025-06-11T18:49:31Z",
          "updatedAt": "2025-06-11T18:49:31Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOKjmGVs64_ezi",
      "title": "Compare to using HTTP Signatures for bot auth",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/7",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We're planning to use HTTP Signatures (RFC 9241) for bot authentication: https://github.com/thibmeu/http-message-signatures-directory. This might be inappropriate for some use cases or deployment scenarios. We should help readers decide whether request client auth is more appropriate.\n\nSpecifically, the draft should spell out the potential efficiency issues and security risks of using HTTP signatures for bot authentication and how these might be addressed with authentication at the TLS level.",
      "createdAt": "2025-05-30T16:09:24Z",
      "updatedAt": "2025-06-11T13:14:16Z",
      "closedAt": "2025-06-11T13:14:15Z",
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOKjmGVs64_fy8",
      "title": "Add reference to draft-meunier-web-bot-auth-architecture",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/8",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The motivation for this draft is primarily to solve the use cases described in https://datatracker.ietf.org/doc/draft-meunier-web-bot-auth-architecture/. We should add an informational reference to this to the intro.\n\nMore generally, we want to enumerate the use cases which this draft might solve for.",
      "createdAt": "2025-05-30T16:11:34Z",
      "updatedAt": "2025-06-11T13:14:15Z",
      "closedAt": "2025-06-11T13:14:15Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOKjmGVs64_nlH",
      "title": "Ensure the flag is safe to enable inadvertently",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/9",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "One concern discussed at IETF 123 is that non-bot clients might propose the flag inadvertently. This is in part a question about proper documentation, but we should also take seriously the question of how to make this safe.\n\nOnce we land #4, the protocol will be something like this: if the client proposes the flag and the server acknowledges it, then the server MUST send CertificateRequest with the acknowledgement.\n\nThe risk seems fairly minimal for this protocol, since the client now knows what code path the server has to selected (client auth with or without the flag). Still, we should play out what might go wrong on the client and side and how an implementation can ensure it does the right thing.",
      "createdAt": "2025-05-30T16:28:37Z",
      "updatedAt": "2025-05-30T16:28:37Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOKjmGVs65374k",
      "title": "Compare to concealed auth for HTTP",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/10",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Could we use https://datatracker.ietf.org/doc/rfc9729/ to bind requests to the TLS channel? Does this work in practice for our main case of bot auth?",
      "createdAt": "2025-06-04T16:41:53Z",
      "updatedAt": "2025-06-11T13:14:15Z",
      "closedAt": "2025-06-11T13:14:15Z",
      "comments": [
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "We tried this initially, but it doesn't play nicely with connection pooling. We tried several different HTTP libraries, and we found that most require you to create a request and dispatch it to the connection pool, whereupon the pool decides which connection it will go on. In some libraries/scenarios the connection isn't even established until the request has been dispatched. This makes constructing the signature very difficult because you can't reliably get the appropriate TLS exporter. At small scale it's possible to manage in a few ways, i.e. not using connection pooling, using callbacks to modify the request after the connection has been selected, or sending dummy get requests with the appropriate header on every connection that gets added to the pool, but each of these has very significant drawbacks when you scale past a few connections. ",
          "createdAt": "2025-06-05T10:07:07Z",
          "updatedAt": "2025-06-05T10:07:07Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOKjmGVs662zJS",
      "title": "Operational Considerations: what are the constraints to consider when choosing how to authenticate bots?",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/12",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add an operational considerations section that justifies this mechanism from an operational perspective. We talk about this a bit in the new appendix in which we list alternatives (see #11), but we should also provide a list of considerations an implementer can take into account when picking between alternatives. Some ideas I've heard:\n\n1. It's much more efficient than HTTP Signatures for the same application (lower communication, less signing/verification)\n2. X.509 certificates gives the deployment a lot more control over key management \n\nAny other thoughts here @jhoyla and @thibmeu?",
      "createdAt": "2025-06-10T21:52:40Z",
      "updatedAt": "2025-06-11T18:56:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "thibmeu",
          "authorAssociation": "NONE",
          "body": "For 1., I'm not sure the number of signing/verification would be that high of an overhead. The current HTTP Message Sigs for bots draft has an open issue about the topic https://github.com/thibmeu/http-message-signatures-directory/issues/4, and could consider clearly mentioning headers compression mechanism as recommended.\n\nfor 2., JWK sets are different than certificates, but already benefit from a wide deployment as well. Keys _could_ be linked to certificates, as part of x5c/x5t field of JWK for instance. This needs more exploration, as mentioned in https://github.com/thibmeu/http-message-signatures-directory/issues/27.\n\nFor operational considerations, I would add:\n3. Ease of deployment. My initial impression is that TLS is a lower level primitive which tends to have controlled exposure in client/server implementations. I'm not sure what's the best term to convey this idea.\n\nIt'd also be great to identify what are the requirements for specific deployments/applications. For instance, a crawler may have a long running connection, while RAG would be more instantaneous. The overhead is likely different.\n\nIn the end, I think the alternative is for Bots/crawler. If two solutions are provided, origins will end up implementing both.",
          "createdAt": "2025-06-11T07:25:14Z",
          "updatedAt": "2025-06-11T07:25:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> For 1., I'm not sure the number of signing/verification would be that high of an overhead. The current HTTP Message Sigs for bots draft has an open issue about the topic [thibmeu/http-message-signatures-directory#4](https://github.com/thibmeu/http-message-signatures-directory/issues/4), and could consider clearly mentioning headers compression mechanism as recommended.\n\nHow would headers compression work? If you have to sign each request, then you also have to verify the signature for each request. At the TLS layer we verify just once.\n\nThat said, one could imagine the cost of signing/verifying each request is not really a problem for web bot auth.\n\n\n> For operational considerations, I would add: 3. Ease of deployment. My initial impression is that TLS is a lower level primitive which tends to have controlled exposure in client/server implementations. I'm not sure what's the best term to convey this idea.\n\nGood one to add. Though I'm not sure we can argue this mechanism would be easier to deploy in all situations. If an implementer has more control over the HTTP stack than their TLS stack, some sort of HTTP-based authentication mechanism might well be easier.\n\n\n> It'd also be great to identify what are the requirements for specific deployments/applications. For instance, a crawler may have a long running connection, while RAG would be more instantaneous. The overhead is likely different.\n\nyeah hopefully the web bot auth BoF will flesh this out a little :)\n\n",
          "createdAt": "2025-06-11T15:11:15Z",
          "updatedAt": "2025-06-11T15:11:15Z"
        },
        {
          "author": "thibmeu",
          "authorAssociation": "NONE",
          "body": "for header compression, I'm thinking of [RFC 7541 HPACK: Header Compression for HTTP/2](https://datatracker.ietf.org/doc/html/rfc7541). The current spec for HTTP Sigs for Bots does not sign request digest, it signs the @authority. This means you can reuse it if the @authority is unchanged and the origins is accepting reuse.",
          "createdAt": "2025-06-11T15:24:54Z",
          "updatedAt": "2025-06-11T15:24:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, interesting. I believe we were missing that detail, @jhoyla. (This also makes me even more nervous about replay attacks.)",
          "createdAt": "2025-06-11T18:56:00Z",
          "updatedAt": "2025-06-11T18:56:00Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOKjmGVs5dd2do",
      "title": "First draft",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/1",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-22T15:12:56Z",
      "updatedAt": "2023-10-22T15:13:24Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "c6a3ba36b4281cc3d98a5abab5ef7a39636d64e1",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "version00",
      "headRefOid": "100998bc6ee53c8397c8432560b141a513b86355",
      "closedAt": "2023-10-22T15:13:24Z",
      "mergedAt": "2023-10-22T15:13:24Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "b656c7b70cbed37b0719c914baeaaf5dff41810c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOKjmGVs5dh17m",
      "title": "First draft",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/2",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-23T13:12:07Z",
      "updatedAt": "2023-10-23T13:16:22Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "1610fe8ff3d1f07f59ea9ddfab986ec757382605",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "version00",
      "headRefOid": "1610fe8ff3d1f07f59ea9ddfab986ec757382605",
      "closedAt": "2023-10-23T13:16:17Z",
      "mergedAt": "2023-10-23T13:16:17Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "1610fe8ff3d1f07f59ea9ddfab986ec757382605"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "PR_kwDOKjmGVs6TcGtu",
      "title": "Client MUST send empty Certificate message",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/4",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Clients that receive `CertificateRequest`s in practice will terminate the connection in anticipation of a \"certificate_required\" alert, rather than sending an empty `Certificate` message, as specified in [RFC-8446, Section 4.4.2](https://www.rfc-editor.org/rfc/rfc8446#section-4.4.2).\r\nThis PR updates the draft to specify that the client MUST send an empty `Certificate` message, and SHOULD NOT terminate the connection in anticipation of a \"certificate_required\" alert.\r\nWe can't require a MUST NOT terminate the connection, as the client might want to terminate the connection for other, unrelated reasons.",
      "createdAt": "2025-04-22T13:20:28Z",
      "updatedAt": "2025-06-09T12:55:18Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "9885460cf74ddbd2ac1bfc70e21ddbc10ae797a7",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "jhoyla/empty-cert-message",
      "headRefOid": "3e5b34c7d8e072683cc328a359358b6eb043ddd0",
      "closedAt": "2025-06-09T12:55:18Z",
      "mergedAt": "2025-06-09T12:55:18Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "b197cbd30ee01853b1d1a176a0b56a1ab5b5575b"
      },
      "comments": [
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "Following comments from @davidben, this has been changed to require the server to echo the flag in the `CertificateRequest` message. This allows the client to determine _why_ the server requested a certificate.",
          "createdAt": "2025-05-27T16:59:21Z",
          "updatedAt": "2025-05-27T16:59:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKjmGVs6rLo26",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T17:27:50Z",
          "updatedAt": "2025-05-27T17:37:50Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "\r\n```suggestion\r\nextra round trip, and requires negotiation at the application layer.\r\n```",
              "createdAt": "2025-05-27T17:27:50Z",
              "updatedAt": "2025-05-27T17:37:50Z"
            },
            {
              "originalPosition": 76,
              "body": "It looks like the server can actually _offer_ TLS flags in CR: https://www.ietf.org/archive/id/draft-ietf-tls-tlsflags-15.html#section-3-4\r\n\r\nIn this case it might not be a good idea to ack the client's offer in CR as well.\r\n\r\nIn any case, I'm a little wary of this draft mandating where a server implementation chooses to acknowledge TLS Flags. The more flexible we can be, the less likely it is for this flag to complicate the implementation of other flags.",
              "createdAt": "2025-05-27T17:37:48Z",
              "updatedAt": "2025-05-27T17:37:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rUkDs",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-28T09:29:49Z",
          "updatedAt": "2025-05-28T09:29:49Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "So I do think we need to specify one place, because otherwise you need logic to handle what to do if the flags disagree. Say the `ServerHello` doesn't set the flag, `EncryptedExtensions` does, and `CertificateRequest` doesn't. Is it an error? Does it being set anywhere => set? \r\n\r\nThe server can offer TLS Flags in `CertificateRequest`, but we can define the `request_mtls` flag to only be valid if it was offered in the `ClientHello`.",
              "createdAt": "2025-05-28T09:29:49Z",
              "updatedAt": "2025-05-28T09:29:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rUowI",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-28T09:36:18Z",
          "updatedAt": "2025-05-28T09:36:19Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Added new language to that effect.",
              "createdAt": "2025-05-28T09:36:18Z",
              "updatedAt": "2025-05-28T09:36:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rdpnz",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-28T23:21:17Z",
          "updatedAt": "2025-05-28T23:21:17Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "I see. The TLS flags draft also requires us to specify which messages in which the flag may appear: https://datatracker.ietf.org/doc/html/draft-ietf-tls-tlsflags-15#section-4-4.3.1",
              "createdAt": "2025-05-28T23:21:17Z",
              "updatedAt": "2025-05-28T23:21:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rdrA-",
          "commit": {
            "abbreviatedOid": "03d2ea7"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-28T23:27:23Z",
          "updatedAt": "2025-05-28T23:51:07Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "How does the client handle the flag if it appears in a different message? Ideally the TLS Flags extension specifies the behavior in this case, but I'm not sure.",
              "createdAt": "2025-05-28T23:27:23Z",
              "updatedAt": "2025-05-28T23:51:07Z"
            },
            {
              "originalPosition": 79,
              "body": "Is this saying the server's acknowledgement (in the \"TLS Flags\" sense) is optional? If so, isn't the server's behavior here the same as if it doesn't implement the req mTLS flag?\r\n\r\nI think the phrase \"wishes to negotiate client authentication for another reason\" is throwing me. Am I right that you're just specifying behavior of servers that don't support this flag?\r\n",
              "createdAt": "2025-05-28T23:32:54Z",
              "updatedAt": "2025-05-28T23:51:07Z"
            },
            {
              "originalPosition": 83,
              "body": "The SHOULD NOT fills me with pause. As I understand it, the goal of this flag is to express to the server that the client will handle the CR in a specific way: respond with an (empty) CT. Is there a legitimate reason why a client might ignore this SHOULD NOT? ",
              "createdAt": "2025-05-28T23:48:03Z",
              "updatedAt": "2025-05-28T23:51:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rhT6e",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T09:15:38Z",
          "updatedAt": "2025-05-29T09:15:38Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "No I'm specifying the behaviour of a server that always asks for a client cert, irrespective of this flag (or possibly is asking for a client cert because of a different flag). If the server always asks for a cert, then the reason it's asking for a cert is _not_ the presence (or absence) of the flag.\r\n\r\nIt's important to specify this behaviour because if the server supports a different TLS Flag (say 82), and has support req mTLS but is not  configured to use it, it needs to know whether to set the flag or not.",
              "createdAt": "2025-05-29T09:15:38Z",
              "updatedAt": "2025-05-29T09:15:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rhYWJ",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T09:23:04Z",
          "updatedAt": "2025-05-29T09:23:04Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "IIUC the behaviour specified in the TLS Flags draft is a fatal `illegal_parameter` alert. \r\n> An endpoint that receives an unsolicited flag in another message (HRR, SH, EE, or CT) MUST generate a fatal illegal_parameter alert.\r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-tls-tlsflags-15#section-3-6\r\nI'll add text making this explicit.",
              "createdAt": "2025-05-29T09:23:04Z",
              "updatedAt": "2025-05-29T09:23:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rhbBn",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T09:27:53Z",
          "updatedAt": "2025-05-29T09:27:53Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Yes. If the server sets the `certificate_authorities` extension, and only lists authorities that the client doesn't support, ditto with `signature_algorithms`. Also, the client may wish to terminate the connection for another reason (e.g. server cert didn't verify), so we shouldn't require them to continue.",
              "createdAt": "2025-05-29T09:27:53Z",
              "updatedAt": "2025-05-29T09:27:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rhfjx",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T09:35:47Z",
          "updatedAt": "2025-05-29T09:35:47Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "This is specified on line 115:\r\n```diff\r\n-* Message shall be CH\r\n+* Message shall be CH, CR\r\n```\r\nStanding for `ClientHello` and `CertificateRequest` respectively.",
              "createdAt": "2025-05-29T09:35:47Z",
              "updatedAt": "2025-05-29T09:35:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rk0A7",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T14:42:41Z",
          "updatedAt": "2025-05-29T14:42:41Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Yes I see that . I would have resolved this thread but am unable to.",
              "createdAt": "2025-05-29T14:42:41Z",
              "updatedAt": "2025-05-29T14:42:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rpPSW",
          "commit": {
            "abbreviatedOid": "ea85945"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T22:02:45Z",
          "updatedAt": "2025-05-29T22:06:11Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "This is interesting because even if the flag on its own has no security impact, the use case we intend to support here -- web bot auth -- certainly does. Namely, we have to override the logic the server uses to decide whether to send a CertificateRequest, how to select a trust anchor to validate the Certificate, and how to handle application data. We don't want to authorize HTTP requests from a crawler that would otherwise require a different client identity.\r\n\r\nGiven the WG feedback so far, I think we'll need to discuss this here. If you'd rather do it in a separate PR, then feel free to just leave a TODO here.",
              "createdAt": "2025-05-29T22:02:45Z",
              "updatedAt": "2025-05-29T22:06:11Z"
            },
            {
              "originalPosition": 40,
              "body": "Along the lines of avoiding the term \"request mutual TLS\", we might rewrite this as\r\n```suggestion\r\nclient to prompt the server to request a certificate during the handshake. Sometimes a server does not want to authenticate every client, but\r\n```",
              "createdAt": "2025-05-29T22:03:50Z",
              "updatedAt": "2025-05-29T22:06:11Z"
            },
            {
              "originalPosition": 62,
              "body": "A bit nit-picky, but: what does \"directly available\" mean? A bot might still need to select a cert based on the contents of the CR.",
              "createdAt": "2025-05-29T22:05:58Z",
              "updatedAt": "2025-05-29T22:06:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rtPWa",
          "commit": {
            "abbreviatedOid": "ea85945"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-30T09:42:26Z",
          "updatedAt": "2025-05-30T09:42:26Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "The goal is to make it clear that you shouldn't set this flag if you aren't certain you have at least one certificate available. You don't want the client to start trying to enumerate keys on a smartcard or prompting the user for a PEM file. This is only supposed to be used if you already know what certificate(s) you have available.",
              "createdAt": "2025-05-30T09:42:26Z",
              "updatedAt": "2025-05-30T09:42:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rtRTZ",
          "commit": {
            "abbreviatedOid": "ea85945"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-30T09:45:28Z",
          "updatedAt": "2025-05-30T09:45:28Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Let's move that to a different PR. What I mean here is that, from a formal methods perspective, this flag is a no-op. The server is always allowed to send a `CertificateRequest`, set CAs, and handle application data in whatever way it likes without affecting the security of the TLS handshake.",
              "createdAt": "2025-05-30T09:45:28Z",
              "updatedAt": "2025-05-30T09:45:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rwDkU",
          "commit": {
            "abbreviatedOid": "ea85945"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-30T14:16:12Z",
          "updatedAt": "2025-05-30T14:16:12Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Filed https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/6.",
              "createdAt": "2025-05-30T14:16:12Z",
              "updatedAt": "2025-05-30T14:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rwLYH",
          "commit": {
            "abbreviatedOid": "3e5b34c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't think this addresses everything, but it's a step in the right direction. I say we merge and iterate.",
          "createdAt": "2025-05-30T14:26:17Z",
          "updatedAt": "2025-05-30T14:26:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOKjmGVs6TcSiJ",
      "title": "Update workflows",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/5",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Update workflows to use correct / modern dependencies.",
      "createdAt": "2025-04-22T13:39:32Z",
      "updatedAt": "2025-04-22T13:40:29Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "1722581ff997d45dbc692a7f79f90a5f09879dfe",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "jhoyla/update-workflows",
      "headRefOid": "d498e46a30cbab46f2115ff38c9df8c707f37feb",
      "closedAt": "2025-04-22T13:40:29Z",
      "mergedAt": "2025-04-22T13:40:28Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "9885460cf74ddbd2ac1bfc70e21ddbc10ae797a7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOKjmGVs6ZsKKn",
      "title": "Add appendix",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/11",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Add appendix discussing alternative solutions.\r\n\r\nCloses #10.\r\nCloses #8.\r\nCloses #7.",
      "createdAt": "2025-06-09T13:55:58Z",
      "updatedAt": "2025-06-11T13:14:14Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "b197cbd30ee01853b1d1a176a0b56a1ab5b5575b",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "jhoyla/feedback",
      "headRefOid": "293e077b7f91bea8ce5b8f7e5f5843c882e65c64",
      "closedAt": "2025-06-11T13:14:14Z",
      "mergedAt": "2025-06-11T13:14:14Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "54a43355c9f4fca50046cc9aa3204c790bbd8f1c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKjmGVs6tfDjU",
          "commit": {
            "abbreviatedOid": "111f038"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Nice! I updated the top comment to reference the issues this PR closes.\r\n",
          "createdAt": "2025-06-09T16:29:28Z",
          "updatedAt": "2025-06-09T16:45:07Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Not a draft anymore ;)\r\n```suggestion\r\nConcealed Auth {{?RFC9729}} allows a client to attach a header\r\n```",
              "createdAt": "2025-06-09T16:29:28Z",
              "updatedAt": "2025-06-09T16:47:10Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nin some contexts, but in the case of authenticating bots may be difficult to\r\n```",
              "createdAt": "2025-06-09T16:30:04Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            },
            {
              "originalPosition": 14,
              "body": "Also, why would this be hard to implement specifically for the bots use case and not others?",
              "createdAt": "2025-06-09T16:32:38Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            },
            {
              "originalPosition": 27,
              "body": "We should mention the possibility of modifying the pooling code.\r\n```suggestion\r\n\r\nIt is possible to avoid this issue, for example by not using connection pooling, or modifying\r\nthe implementation so that the first request on each new connection includes the binding.\r\nIf modifying the implementation is not possible, then there are some ad-hoc options, such as\r\nsending a special \"pre-request\" on each connection that's added to a pool,\r\nhowever these solutions tend to be bespoke per library and bring a number of\r\ntheir own issues (e.g. handling servers that terminate connections after a\r\nsingle request, or handling resumption).\r\n```",
              "createdAt": "2025-06-09T16:38:35Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            },
            {
              "originalPosition": 35,
              "body": "Add a reference for these reservations.",
              "createdAt": "2025-06-09T16:39:38Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            },
            {
              "originalPosition": 41,
              "body": "Say why this is functionally equivalent. We might need to flesh out the proposal a bit more.",
              "createdAt": "2025-06-09T16:40:48Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            },
            {
              "originalPosition": 50,
              "body": "Mention the CDN use case specifically.",
              "createdAt": "2025-06-09T16:41:11Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            },
            {
              "originalPosition": 43,
              "body": "I would put this section first since this draft shares the same exact motivation as ours. I would also mention the shared motivation explicitly.",
              "createdAt": "2025-06-09T16:41:48Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6tskeu",
          "commit": {
            "abbreviatedOid": "111f038"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-10T15:38:14Z",
          "updatedAt": "2025-06-10T15:38:14Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "So this is addressed in the next sentence.",
              "createdAt": "2025-06-10T15:38:14Z",
              "updatedAt": "2025-06-10T15:38:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6tsrwa",
          "commit": {
            "abbreviatedOid": "111f038"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-10T15:46:43Z",
          "updatedAt": "2025-06-10T15:46:43Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Do you mean this:\r\n\r\n> The way many HTTP libraries work is that they dispatch requests to a connection\r\npool. Once the request arrives at the pool it is sent on a chosen connection\r\ndriven by internal logic. This, unfortunately, makes it difficult to know which\r\nconnection a request will be sent on, and thus to produce the appropriate\r\nsignature.\r\n\r\nThis seems to be about any application that uses a connection pool. Are you suggesting that the use of connection pools is more common for bots than for non-bots?\r\n\r\nWhich reminds me of what we're discussing in https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/3#issuecomment-2959730400: how exactly are we defining bot? Does the definition of bot matter here?",
              "createdAt": "2025-06-10T15:46:43Z",
              "updatedAt": "2025-06-10T15:46:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6ttXVe",
          "commit": {
            "abbreviatedOid": "0473a96"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d \r\n",
          "createdAt": "2025-06-10T16:45:56Z",
          "updatedAt": "2025-06-10T19:18:56Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'm not sure it's correct to call it a bearer token. I think of a bearer token as just a shared secret.\r\n```suggestion\r\nmechanism for implementing HTTP authentication. This mechanism suffers from a number of drawbacks, notably that a new\r\n```",
              "createdAt": "2025-06-10T16:45:57Z",
              "updatedAt": "2025-06-10T19:18:56Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nin the multi-CDN (\"Content Distribution Network\") use case. If a bot creates a token for a realm that is provided\r\n```",
              "createdAt": "2025-06-10T19:14:07Z",
              "updatedAt": "2025-06-10T19:18:56Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\neach connection that's added to a pool. However these solutions tend to be\r\n```",
              "createdAt": "2025-06-10T19:15:22Z",
              "updatedAt": "2025-06-10T19:18:56Z"
            },
            {
              "originalPosition": 28,
              "body": "I don't see how the next paragraph is about bots specifically: see  but in the case of authenticating bots may be\r\ndifficult to implement.\r\n\r\n```suggestion\r\napplicable in some contexts, but may be\r\ndifficult to implement.\r\n```",
              "createdAt": "2025-06-10T19:17:22Z",
              "updatedAt": "2025-06-10T19:18:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6twSRC",
          "commit": {
            "abbreviatedOid": "0473a96"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-10T21:47:35Z",
          "updatedAt": "2025-06-10T21:47:36Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "nit: consistent title capitalization (or let me know if you're following a convention I'm aware of)\r\n```suggestion\r\n### Post-handshake Authentication (PHA)\r\n```",
              "createdAt": "2025-06-10T21:47:35Z",
              "updatedAt": "2025-06-10T21:47:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6twSVs",
          "commit": {
            "abbreviatedOid": "0473a96"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-10T21:47:48Z",
          "updatedAt": "2025-06-10T21:47:48Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "nit: same as above\r\n```suggestion\r\n### Client-Initiated Exported Authenticators\r\n```",
              "createdAt": "2025-06-10T21:47:48Z",
              "updatedAt": "2025-06-10T21:47:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t3hiq",
          "commit": {
            "abbreviatedOid": "0473a96"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T12:51:46Z",
          "updatedAt": "2025-06-11T12:51:46Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "A bearer token is anything that simple possession of grants access, i.e. they are always transferable. It doesn't need to involve a shared secret, it can be, for example a signed blob. ",
              "createdAt": "2025-06-11T12:51:46Z",
              "updatedAt": "2025-06-11T12:51:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOKjmGVs6aCabu",
      "title": "Mostly editorial",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/13",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Upon reading the draft I wanted to split up some of the bigger paragraphs into smaller ones. I also noticed that we use BCP 14 key words in the intro, before they're defined, and thought we should avoid this.",
      "createdAt": "2025-06-11T13:47:51Z",
      "updatedAt": "2025-06-11T18:39:05Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "54a43355c9f4fca50046cc9aa3204c790bbd8f1c",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "cjpatton/editorial",
      "headRefOid": "97db794a963bed16782c4ee64065216a40c3626f",
      "closedAt": "2025-06-11T18:39:05Z",
      "mergedAt": "2025-06-11T18:39:05Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ec68e0573e57f8f06f14328a0bddebea0267f1ff"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKjmGVs6t6-bp",
          "commit": {
            "abbreviatedOid": "631d3a5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T16:22:33Z",
          "updatedAt": "2025-06-11T16:24:05Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Why make this non-normative?",
              "createdAt": "2025-06-11T16:22:33Z",
              "updatedAt": "2025-06-11T16:24:05Z"
            },
            {
              "originalPosition": 23,
              "body": "I def. think this is a hard requirement.",
              "createdAt": "2025-06-11T16:23:06Z",
              "updatedAt": "2025-06-11T16:24:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7Eh4",
          "commit": {
            "abbreviatedOid": "631d3a5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T16:31:55Z",
          "updatedAt": "2025-06-11T16:31:55Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "because this is section 1 and  we don't introduced the BCP 14 key words until section 2",
              "createdAt": "2025-06-11T16:31:55Z",
              "updatedAt": "2025-06-11T16:31:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7HPq",
          "commit": {
            "abbreviatedOid": "631d3a5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T16:35:17Z",
          "updatedAt": "2025-06-11T16:35:17Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I don't have an issue with this being normative, my point is that editorially it doesn't make sense to have normative text here.",
              "createdAt": "2025-06-11T16:35:17Z",
              "updatedAt": "2025-06-11T16:35:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7bnP",
          "commit": {
            "abbreviatedOid": "631d3a5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T17:04:11Z",
          "updatedAt": "2025-06-11T17:04:11Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Ah ok, could you possibly put the normative language in later on then?",
              "createdAt": "2025-06-11T17:04:11Z",
              "updatedAt": "2025-06-11T17:04:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7bv7",
          "commit": {
            "abbreviatedOid": "631d3a5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-11T17:04:22Z",
          "updatedAt": "2025-06-11T17:04:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKjmGVs6t8e0v",
          "commit": {
            "abbreviatedOid": "631d3a5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T18:38:32Z",
          "updatedAt": "2025-06-11T18:38:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Done.",
              "createdAt": "2025-06-11T18:38:32Z",
              "updatedAt": "2025-06-11T18:38:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOKjmGVs6aCcq1",
      "title": "Rename to req_bot_auth.",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/14",
      "state": "OPEN",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-11T13:50:41Z",
      "updatedAt": "2025-06-11T14:51:01Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "54a43355c9f4fca50046cc9aa3204c790bbd8f1c",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "jhoyla/rename",
      "headRefOid": "3754c89ee7f06eb9509e9e1b0d0f5e147def3ae8",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKjmGVs6t4-RH",
          "commit": {
            "abbreviatedOid": "3754c89"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I've put up a #15 that might be a more appropriate first step. Would you mind taking a look?",
          "createdAt": "2025-06-11T14:06:42Z",
          "updatedAt": "2025-06-11T14:51:01Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I like the abstract as is. Perhaps just tack on a sentence that says something like \"the primary use case for this mechanism is ...\"",
              "createdAt": "2025-06-11T14:06:42Z",
              "updatedAt": "2025-06-11T14:51:01Z"
            },
            {
              "originalPosition": 31,
              "body": "Can we try to keep lines wrapped at 80 columns?",
              "createdAt": "2025-06-11T14:07:09Z",
              "updatedAt": "2025-06-11T14:51:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOKjmGVs6aDGYs",
      "title": "Address the possibility of the flag introducing authentication bugs in implementations",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/15",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #3. Describe web bot auth as our primary use case, but still allow for the possibility of using the flag for different use cases. The main purpose of this text is to scope the draft's security considerations to web bot auth.\r\n\r\nCloses #6 by recommending use of a separate set of trust anchors with this extension, which seems easy to enforce for our use case.",
      "createdAt": "2025-06-11T14:43:22Z",
      "updatedAt": "2025-06-11T18:48:58Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "ec68e0573e57f8f06f14328a0bddebea0267f1ff",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "cjpatton/6",
      "headRefOid": "ffd7736d448d175fe0cf69a7cf13658c96978e7b",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Changed base.",
          "createdAt": "2025-06-11T18:40:47Z",
          "updatedAt": "2025-06-11T18:40:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed a couple of typos.",
          "createdAt": "2025-06-11T18:48:57Z",
          "updatedAt": "2025-06-11T18:48:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKjmGVs6t7AJ2",
          "commit": {
            "abbreviatedOid": "062efa8"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T16:25:10Z",
          "updatedAt": "2025-06-11T16:31:40Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Based on the feedback we've had, I think we'll only get rough consensus if we restrict this to only the bot use case.",
              "createdAt": "2025-06-11T16:25:10Z",
              "updatedAt": "2025-06-11T16:31:40Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nspoofed {{?I-D.draft-meunier-web-bot-auth-architecture}}.\r\n```\r\nIt's not specifically network attackers?",
              "createdAt": "2025-06-11T16:29:34Z",
              "updatedAt": "2025-06-11T16:31:40Z"
            },
            {
              "originalPosition": 75,
              "body": "```suggestion\r\nchanges to how the client selects a certificate and how the server\r\n```\r\nIt doesn't change _how_ the server validates does it? Only what it validates against?",
              "createdAt": "2025-06-11T16:31:24Z",
              "updatedAt": "2025-06-11T16:31:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7NaQ",
          "commit": {
            "abbreviatedOid": "2c38ffa"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T16:43:13Z",
          "updatedAt": "2025-06-11T16:44:05Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "That's what I mean. Changed to \"which trust anchor the server uses to validate it.\"",
              "createdAt": "2025-06-11T16:43:13Z",
              "updatedAt": "2025-06-11T16:44:05Z"
            },
            {
              "originalPosition": 15,
              "body": "Agreed, but my intention was to leave that to a future to address. That is,this PR merely partially addresses #3, but doesn't close it.",
              "createdAt": "2025-06-11T16:44:01Z",
              "updatedAt": "2025-06-11T16:44:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7eD0",
          "commit": {
            "abbreviatedOid": "a1a89a2"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T17:06:47Z",
          "updatedAt": "2025-06-11T17:06:47Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "```suggestion\r\ncertificate to grant certain clients access to some resource, the server must take\r\n```",
              "createdAt": "2025-06-11T17:06:47Z",
              "updatedAt": "2025-06-11T17:06:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7eSV",
          "commit": {
            "abbreviatedOid": "a1a89a2"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-11T17:06:59Z",
          "updatedAt": "2025-06-11T17:06:59Z",
          "comments": []
        }
      ]
    }
  ]
}