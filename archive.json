{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-06-08T00:34:00.618534+00:00",
  "repo": "jhoyla/draft-jhoyla-req-mtls-flag",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOKjmGVs6ufiKv",
      "title": "Should this be \"request-mtls\" or should this be \"request-bot-auth\"?",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/3",
      "state": "OPEN",
      "author": "bob-beck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"This enables a number of use cases, for example allowing bots to authenticate themselves when mixed in with general traffic.\"\n\nAfter some discussion with you and others seems to indicate that there may be an opinion that \"browsers shouldn't do this\"\n\nIf the intention is truly for \"bot-auth\" should this really be about only bot-auth - and perhaps include being opinionated about what the bot-auth is to perhaps simplify the resulting pki for this? (maybe not just any old X.509 certificate blob with path building etc,  but perhaps something more limited or even a raw public key to encourage dedicated trust stores for this purpose?)\n\nOr is the intention here to be a generic \"it's safe to send me a certificate request\" that browsers/clients/things-not-bots could possibly start using for certain things - and leaving \"bot-auth\" to have to disambiguate the cases (i.e. what trust store to use) on the server by other means if both are in use. \n",
      "createdAt": "2025-03-18T07:49:25Z",
      "updatedAt": "2025-03-18T07:49:25Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOKjmGVs64-a8l",
      "title": "Security Considerations: Address risk of making authentication logic more complex",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/6",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is interesting because even if the flag on its own has no security impact, the use case we intend to support here -- web bot auth -- certainly does. Namely, we have to override the logic the server uses to decide whether to send a CertificateRequest, how to select a trust anchor to validate the Certificate, and how to handle application data. We don't want to authorize HTTP requests from a crawler that would otherwise require a different client identity.\r\n\r\nGiven the WG feedback so far, I think we'll need to discuss this here. If you'd rather do it in a separate PR, then feel free to just leave a TODO here.\r\n\r\n_Originally posted by @cjpatton in https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/4#discussion_r2114816776_\r\n            ",
      "createdAt": "2025-05-30T14:15:26Z",
      "updatedAt": "2025-05-30T16:21:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: The scope of this issue might change if (1) we decide to scope the draft to \"request bot auth\" (#3) and (2) we decide the draft itself should manage the complexity of authentication logic, e.g., by partitioning the set of trust anchors and spelling out requirements for CAs.",
          "createdAt": "2025-05-30T16:02:44Z",
          "updatedAt": "2025-05-30T16:02:44Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOKjmGVs64_ezi",
      "title": "Compare to using HTTP Signatures for bot auth",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/7",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We're planning to use HTTP Signatures (RFC 9241) for bot authentication: https://github.com/thibmeu/http-message-signatures-directory. This might be inappropriate for some use cases or deployment scenarios. We should help readers decide whether request client auth is more appropriate.\n\nSpecifically, the draft should spell out the potential efficiency issues and security risks of using HTTP signatures for bot authentication and how these might be addressed with authentication at the TLS level.",
      "createdAt": "2025-05-30T16:09:24Z",
      "updatedAt": "2025-05-30T16:09:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOKjmGVs64_fy8",
      "title": "Add reference to draft-meunier-web-bot-auth-architecture",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/8",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The motivation for this draft is primarily to solve the use cases described in https://datatracker.ietf.org/doc/draft-meunier-web-bot-auth-architecture/. We should add an informational reference to this to the intro.\n\nMore generally, we want to enumerate the use cases which this draft might solve for.",
      "createdAt": "2025-05-30T16:11:34Z",
      "updatedAt": "2025-05-30T16:20:50Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOKjmGVs64_nlH",
      "title": "Ensure the flag is safe to enable inadvertently",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/9",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "One concern discussed at IETF 123 is that non-bot clients might propose the flag inadvertently. This is in part a question about proper documentation, but we should also take seriously the question of how to make this safe.\n\nOnce we land #4, the protocol will be something like this: if the client proposes the flag and the server acknowledges it, then the server MUST send CertificateRequest with the acknowledgement.\n\nThe risk seems fairly minimal for this protocol, since the client now knows what code path the server has to selected (client auth with or without the flag). Still, we should play out what might go wrong on the client and side and how an implementation can ensure it does the right thing.",
      "createdAt": "2025-05-30T16:28:37Z",
      "updatedAt": "2025-05-30T16:28:37Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOKjmGVs65374k",
      "title": "Compare to concealed auth for HTTP",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/10",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Could we use https://datatracker.ietf.org/doc/rfc9729/ to bind requests to the TLS channel? Does this work in practice for our main case of bot auth?",
      "createdAt": "2025-06-04T16:41:53Z",
      "updatedAt": "2025-06-05T10:07:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "We tried this initially, but it doesn't play nicely with connection pooling. We tried several different HTTP libraries, and we found that most require you to create a request and dispatch it to the connection pool, whereupon the pool decides which connection it will go on. In some libraries/scenarios the connection isn't even established until the request has been dispatched. This makes constructing the signature very difficult because you can't reliably get the appropriate TLS exporter. At small scale it's possible to manage in a few ways, i.e. not using connection pooling, using callbacks to modify the request after the connection has been selected, or sending dummy get requests with the appropriate header on every connection that gets added to the pool, but each of these has very significant drawbacks when you scale past a few connections. ",
          "createdAt": "2025-06-05T10:07:07Z",
          "updatedAt": "2025-06-05T10:07:07Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOKjmGVs5dd2do",
      "title": "First draft",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/1",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-22T15:12:56Z",
      "updatedAt": "2023-10-22T15:13:24Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "c6a3ba36b4281cc3d98a5abab5ef7a39636d64e1",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "version00",
      "headRefOid": "100998bc6ee53c8397c8432560b141a513b86355",
      "closedAt": "2023-10-22T15:13:24Z",
      "mergedAt": "2023-10-22T15:13:24Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "b656c7b70cbed37b0719c914baeaaf5dff41810c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOKjmGVs5dh17m",
      "title": "First draft",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/2",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-23T13:12:07Z",
      "updatedAt": "2023-10-23T13:16:22Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "1610fe8ff3d1f07f59ea9ddfab986ec757382605",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "version00",
      "headRefOid": "1610fe8ff3d1f07f59ea9ddfab986ec757382605",
      "closedAt": "2023-10-23T13:16:17Z",
      "mergedAt": "2023-10-23T13:16:17Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "1610fe8ff3d1f07f59ea9ddfab986ec757382605"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "PR_kwDOKjmGVs6TcGtu",
      "title": "Client MUST send empty Certificate message",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/4",
      "state": "OPEN",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Clients that receive `CertificateRequest`s in practice will terminate the connection in anticipation of a \"certificate_required\" alert, rather than sending an empty `Certificate` message, as specified in [RFC-8446, Section 4.4.2](https://www.rfc-editor.org/rfc/rfc8446#section-4.4.2).\r\nThis PR updates the draft to specify that the client MUST send an empty `Certificate` message, and SHOULD NOT terminate the connection in anticipation of a \"certificate_required\" alert.\r\nWe can't require a MUST NOT terminate the connection, as the client might want to terminate the connection for other, unrelated reasons.",
      "createdAt": "2025-04-22T13:20:28Z",
      "updatedAt": "2025-05-30T14:26:17Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "9885460cf74ddbd2ac1bfc70e21ddbc10ae797a7",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "jhoyla/empty-cert-message",
      "headRefOid": "3e5b34c7d8e072683cc328a359358b6eb043ddd0",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "Following comments from @davidben, this has been changed to require the server to echo the flag in the `CertificateRequest` message. This allows the client to determine _why_ the server requested a certificate.",
          "createdAt": "2025-05-27T16:59:21Z",
          "updatedAt": "2025-05-27T16:59:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKjmGVs6rLo26",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T17:27:50Z",
          "updatedAt": "2025-05-27T17:37:50Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "\r\n```suggestion\r\nextra round trip, and requires negotiation at the application layer.\r\n```",
              "createdAt": "2025-05-27T17:27:50Z",
              "updatedAt": "2025-05-27T17:37:50Z"
            },
            {
              "originalPosition": 76,
              "body": "It looks like the server can actually _offer_ TLS flags in CR: https://www.ietf.org/archive/id/draft-ietf-tls-tlsflags-15.html#section-3-4\r\n\r\nIn this case it might not be a good idea to ack the client's offer in CR as well.\r\n\r\nIn any case, I'm a little wary of this draft mandating where a server implementation chooses to acknowledge TLS Flags. The more flexible we can be, the less likely it is for this flag to complicate the implementation of other flags.",
              "createdAt": "2025-05-27T17:37:48Z",
              "updatedAt": "2025-05-27T17:37:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rUkDs",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-28T09:29:49Z",
          "updatedAt": "2025-05-28T09:29:49Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "So I do think we need to specify one place, because otherwise you need logic to handle what to do if the flags disagree. Say the `ServerHello` doesn't set the flag, `EncryptedExtensions` does, and `CertificateRequest` doesn't. Is it an error? Does it being set anywhere => set? \r\n\r\nThe server can offer TLS Flags in `CertificateRequest`, but we can define the `request_mtls` flag to only be valid if it was offered in the `ClientHello`.",
              "createdAt": "2025-05-28T09:29:49Z",
              "updatedAt": "2025-05-28T09:29:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rUowI",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-28T09:36:18Z",
          "updatedAt": "2025-05-28T09:36:19Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Added new language to that effect.",
              "createdAt": "2025-05-28T09:36:18Z",
              "updatedAt": "2025-05-28T09:36:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rdpnz",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-28T23:21:17Z",
          "updatedAt": "2025-05-28T23:21:17Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "I see. The TLS flags draft also requires us to specify which messages in which the flag may appear: https://datatracker.ietf.org/doc/html/draft-ietf-tls-tlsflags-15#section-4-4.3.1",
              "createdAt": "2025-05-28T23:21:17Z",
              "updatedAt": "2025-05-28T23:21:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rdrA-",
          "commit": {
            "abbreviatedOid": "03d2ea7"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-28T23:27:23Z",
          "updatedAt": "2025-05-28T23:51:07Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "How does the client handle the flag if it appears in a different message? Ideally the TLS Flags extension specifies the behavior in this case, but I'm not sure.",
              "createdAt": "2025-05-28T23:27:23Z",
              "updatedAt": "2025-05-28T23:51:07Z"
            },
            {
              "originalPosition": 79,
              "body": "Is this saying the server's acknowledgement (in the \"TLS Flags\" sense) is optional? If so, isn't the server's behavior here the same as if it doesn't implement the req mTLS flag?\r\n\r\nI think the phrase \"wishes to negotiate client authentication for another reason\" is throwing me. Am I right that you're just specifying behavior of servers that don't support this flag?\r\n",
              "createdAt": "2025-05-28T23:32:54Z",
              "updatedAt": "2025-05-28T23:51:07Z"
            },
            {
              "originalPosition": 83,
              "body": "The SHOULD NOT fills me with pause. As I understand it, the goal of this flag is to express to the server that the client will handle the CR in a specific way: respond with an (empty) CT. Is there a legitimate reason why a client might ignore this SHOULD NOT? ",
              "createdAt": "2025-05-28T23:48:03Z",
              "updatedAt": "2025-05-28T23:51:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rhT6e",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T09:15:38Z",
          "updatedAt": "2025-05-29T09:15:38Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "No I'm specifying the behaviour of a server that always asks for a client cert, irrespective of this flag (or possibly is asking for a client cert because of a different flag). If the server always asks for a cert, then the reason it's asking for a cert is _not_ the presence (or absence) of the flag.\r\n\r\nIt's important to specify this behaviour because if the server supports a different TLS Flag (say 82), and has support req mTLS but is not  configured to use it, it needs to know whether to set the flag or not.",
              "createdAt": "2025-05-29T09:15:38Z",
              "updatedAt": "2025-05-29T09:15:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rhYWJ",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T09:23:04Z",
          "updatedAt": "2025-05-29T09:23:04Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "IIUC the behaviour specified in the TLS Flags draft is a fatal `illegal_parameter` alert. \r\n> An endpoint that receives an unsolicited flag in another message (HRR, SH, EE, or CT) MUST generate a fatal illegal_parameter alert.\r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-tls-tlsflags-15#section-3-6\r\nI'll add text making this explicit.",
              "createdAt": "2025-05-29T09:23:04Z",
              "updatedAt": "2025-05-29T09:23:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rhbBn",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T09:27:53Z",
          "updatedAt": "2025-05-29T09:27:53Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Yes. If the server sets the `certificate_authorities` extension, and only lists authorities that the client doesn't support, ditto with `signature_algorithms`. Also, the client may wish to terminate the connection for another reason (e.g. server cert didn't verify), so we shouldn't require them to continue.",
              "createdAt": "2025-05-29T09:27:53Z",
              "updatedAt": "2025-05-29T09:27:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rhfjx",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T09:35:47Z",
          "updatedAt": "2025-05-29T09:35:47Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "This is specified on line 115:\r\n```diff\r\n-* Message shall be CH\r\n+* Message shall be CH, CR\r\n```\r\nStanding for `ClientHello` and `CertificateRequest` respectively.",
              "createdAt": "2025-05-29T09:35:47Z",
              "updatedAt": "2025-05-29T09:35:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rk0A7",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T14:42:41Z",
          "updatedAt": "2025-05-29T14:42:41Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Yes I see that . I would have resolved this thread but am unable to.",
              "createdAt": "2025-05-29T14:42:41Z",
              "updatedAt": "2025-05-29T14:42:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rpPSW",
          "commit": {
            "abbreviatedOid": "ea85945"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T22:02:45Z",
          "updatedAt": "2025-05-29T22:06:11Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "This is interesting because even if the flag on its own has no security impact, the use case we intend to support here -- web bot auth -- certainly does. Namely, we have to override the logic the server uses to decide whether to send a CertificateRequest, how to select a trust anchor to validate the Certificate, and how to handle application data. We don't want to authorize HTTP requests from a crawler that would otherwise require a different client identity.\r\n\r\nGiven the WG feedback so far, I think we'll need to discuss this here. If you'd rather do it in a separate PR, then feel free to just leave a TODO here.",
              "createdAt": "2025-05-29T22:02:45Z",
              "updatedAt": "2025-05-29T22:06:11Z"
            },
            {
              "originalPosition": 40,
              "body": "Along the lines of avoiding the term \"request mutual TLS\", we might rewrite this as\r\n```suggestion\r\nclient to prompt the server to request a certificate during the handshake. Sometimes a server does not want to authenticate every client, but\r\n```",
              "createdAt": "2025-05-29T22:03:50Z",
              "updatedAt": "2025-05-29T22:06:11Z"
            },
            {
              "originalPosition": 62,
              "body": "A bit nit-picky, but: what does \"directly available\" mean? A bot might still need to select a cert based on the contents of the CR.",
              "createdAt": "2025-05-29T22:05:58Z",
              "updatedAt": "2025-05-29T22:06:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rtPWa",
          "commit": {
            "abbreviatedOid": "ea85945"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-30T09:42:26Z",
          "updatedAt": "2025-05-30T09:42:26Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "The goal is to make it clear that you shouldn't set this flag if you aren't certain you have at least one certificate available. You don't want the client to start trying to enumerate keys on a smartcard or prompting the user for a PEM file. This is only supposed to be used if you already know what certificate(s) you have available.",
              "createdAt": "2025-05-30T09:42:26Z",
              "updatedAt": "2025-05-30T09:42:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rtRTZ",
          "commit": {
            "abbreviatedOid": "ea85945"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-30T09:45:28Z",
          "updatedAt": "2025-05-30T09:45:28Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Let's move that to a different PR. What I mean here is that, from a formal methods perspective, this flag is a no-op. The server is always allowed to send a `CertificateRequest`, set CAs, and handle application data in whatever way it likes without affecting the security of the TLS handshake.",
              "createdAt": "2025-05-30T09:45:28Z",
              "updatedAt": "2025-05-30T09:45:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rwDkU",
          "commit": {
            "abbreviatedOid": "ea85945"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-30T14:16:12Z",
          "updatedAt": "2025-05-30T14:16:12Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Filed https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/6.",
              "createdAt": "2025-05-30T14:16:12Z",
              "updatedAt": "2025-05-30T14:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rwLYH",
          "commit": {
            "abbreviatedOid": "3e5b34c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't think this addresses everything, but it's a step in the right direction. I say we merge and iterate.",
          "createdAt": "2025-05-30T14:26:17Z",
          "updatedAt": "2025-05-30T14:26:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOKjmGVs6TcSiJ",
      "title": "Update workflows",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/5",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Update workflows to use correct / modern dependencies.",
      "createdAt": "2025-04-22T13:39:32Z",
      "updatedAt": "2025-04-22T13:40:29Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "1722581ff997d45dbc692a7f79f90a5f09879dfe",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "jhoyla/update-workflows",
      "headRefOid": "d498e46a30cbab46f2115ff38c9df8c707f37feb",
      "closedAt": "2025-04-22T13:40:29Z",
      "mergedAt": "2025-04-22T13:40:28Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "9885460cf74ddbd2ac1bfc70e21ddbc10ae797a7"
      },
      "comments": [],
      "reviews": []
    }
  ]
}