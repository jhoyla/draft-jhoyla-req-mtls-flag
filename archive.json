{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-06-22T00:34:13.447596+00:00",
  "repo": "jhoyla/draft-jhoyla-req-mtls-flag",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOKjmGVs6ufiKv",
      "title": "Should this be \"request-mtls\" or should this be \"request-bot-auth\"?",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/3",
      "state": "CLOSED",
      "author": "bob-beck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"This enables a number of use cases, for example allowing bots to authenticate themselves when mixed in with general traffic.\"\n\nAfter some discussion with you and others seems to indicate that there may be an opinion that \"browsers shouldn't do this\"\n\nIf the intention is truly for \"bot-auth\" should this really be about only bot-auth - and perhaps include being opinionated about what the bot-auth is to perhaps simplify the resulting pki for this? (maybe not just any old X.509 certificate blob with path building etc,  but perhaps something more limited or even a raw public key to encourage dedicated trust stores for this purpose?)\n\nOr is the intention here to be a generic \"it's safe to send me a certificate request\" that browsers/clients/things-not-bots could possibly start using for certain things - and leaving \"bot-auth\" to have to disambiguate the cases (i.e. what trust store to use) on the server by other means if both are in use. \n",
      "createdAt": "2025-03-18T07:49:25Z",
      "updatedAt": "2025-06-19T18:54:40Z",
      "closedAt": "2025-06-19T18:54:39Z",
      "comments": [
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "So after discussions with various people, there seems to be a strong push for this to be \"bot-auth\" only. That's probably ok, as long as we're not too specific about what \"bot\" means. \n\nI don't like the idea of raw public keys, because it requires us to reinvent a number of wheels, e.g. expiry, rotation, delegation, binding names to keys, provisioning, etc. Restricting the certs to SPIFFE certs holds a certain appeal to me, but I'm not sure what others think. @cjpatton?",
          "createdAt": "2025-06-09T17:10:20Z",
          "updatedAt": "2025-06-09T17:10:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't have an especially strong opinion here. We certainly should try to keep the PKI simple, but I don't see a reason to go as far as using raw public keys rather than X.509. Rather we might try to be prescriptive about how the server selects trust anchors when the flag is negotiated.",
          "createdAt": "2025-06-09T17:46:33Z",
          "updatedAt": "2025-06-09T17:46:33Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "I await the chatgpt generated bike sheds for the definition of a bot, but to me at least at the moment for this draft I think it means \"There is no meatspace entity sitting at a keyboard causing this connection to be made with interactive expectations\".  \n\"I am not a web browser\". ",
          "createdAt": "2025-06-09T17:52:44Z",
          "updatedAt": "2025-06-09T17:52:44Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "I agree with keeping it simple, and I don't think bringing in extra opinions in this draft about what form the certificate will take will help that unless we can't solve an issue any other way.   \n\n",
          "createdAt": "2025-06-09T17:54:49Z",
          "updatedAt": "2025-06-09T17:54:49Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "Assuming a server is responding with an echo'ed flag in a certificate request message, the server can either choose to include the CA extension (or possibly in the future TLS Trust Anchor IDs) to tell the client what it wants, or not include it and the client today gets to \"guess\" based on \"ecosystem expectation\" like any other time one end of a TLS connection gets to send a cert without being given a hint. \n\nIf the client doesn't want to \"guess\" it's of course free to send the empty certificate and the server decides if it wants to continue. \n\nIs there a problem with that model here? if not we don't need to say anything. ",
          "createdAt": "2025-06-09T18:05:44Z",
          "updatedAt": "2025-06-09T18:07:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The only problem I can see is if the server conflates the bot PKI with the existing PKI it currently uses for the client authentication, e.g., by allowing a cross-sign of a bot cert by the exiting PKI or vise versa. But I don't know that there's a protocol change that could avoid that.",
          "createdAt": "2025-06-09T18:20:59Z",
          "updatedAt": "2025-06-09T18:22:25Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "But of course it might do that intentionally.  \n\nSo, is this scenario a valid use case or not: \n\nI am Bob. I use a client cert signed by a root from honestachmed.ca to authenticate myself for access to POST things to several API's on the site. so /api/foo, /api/bar, and /api/global-thermonuclear-war.\n\nI also write/use agentic bots to do things on my behalf. they do things as me, with my cert. \n\nThe server differentiates on the client sending the \"I am a bot\" extension to only grant bob as a bot access to api/foo and api/bar, and not api/global-thermonuclear-war. \n\nNow, I'm not strictly saying this is a good idea or a bad idea. but it's something someone might do. ",
          "createdAt": "2025-06-09T18:41:39Z",
          "updatedAt": "2025-06-09T18:41:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this example shows that \"human-in-the-loop\" is not the right way to think of \"bot\". What matters to us I think is what access is granted to the client, not whether the client is human or a bot acting on behalf of a human. See https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/6#issuecomment-2956638120.",
          "createdAt": "2025-06-09T18:50:56Z",
          "updatedAt": "2025-06-09T18:50:56Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "So @thibmeu has an interesting definition of a bot for the purposes of HTTP Sigs, which is that \"a bot is something with no expectation of privacy\". I actually really like this framing, because it makes it clear when you should and shouldn't use this, or rather, which identities go in the certificate. If you are an agent acting for some user (I've been using the word [principal](https://en.wikipedia.org/wiki/Principal_(commercial_law)) to capture the idea of the person directing the bot just because I can't think of a better one, suggestions extremely welcome), then whilst the user might have some expectation of privacy, the agent (the controller of the private key) here does not.",
          "createdAt": "2025-06-10T14:43:31Z",
          "updatedAt": "2025-06-10T14:43:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't believe that definition is sufficient for our purposes because it doesn't fully account for how we handle requests from humans versus bots. Privacy is just one facet of this.",
          "createdAt": "2025-06-10T14:54:46Z",
          "updatedAt": "2025-06-10T14:55:44Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "I'm not convinced that there is any useful definition of a bot beyond defining it as \"not human\". Maybe just privacy isn't sufficient, but I do like framing in terms of \"what rights do humans have that we don't need to honour here\".",
          "createdAt": "2025-06-10T15:31:22Z",
          "updatedAt": "2025-06-10T15:31:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "That's kind of my point: we don't _need_ to define \"bot\". All we need to define is how we handle traffic from a client that identifies themself as a bot.",
          "createdAt": "2025-06-10T15:40:25Z",
          "updatedAt": "2025-06-10T15:40:25Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "I agree in that focusing on a definition of a bot is probably tangential, the desired goal is to define what the extension is supposed to be used for and write a useful security concerns section to guide implementors on what they should and should not do with it. \n\n",
          "createdAt": "2025-06-10T17:39:11Z",
          "updatedAt": "2025-06-10T17:39:11Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The semantics we're leaning towards is the extension indicates which PKI the client is part of. This might be broader than a flag indicating use of some \"web bot auth PKI\". And in any case, using a flag to do so sets a bad precedent for others who might want to prompt CR request for other use cases.\n\nAs such I don't think there's anything more to do for this issue.",
          "createdAt": "2025-06-19T18:54:39Z",
          "updatedAt": "2025-06-19T18:54:39Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOKjmGVs64-a8l",
      "title": "Security Considerations: Address risk of making authentication logic more complex",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/6",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is interesting because even if the flag on its own has no security impact, the use case we intend to support here -- web bot auth -- certainly does. Namely, we have to override the logic the server uses to decide whether to send a CertificateRequest, how to select a trust anchor to validate the Certificate, and how to handle application data. We don't want to authorize HTTP requests from a crawler that would otherwise require a different client identity.\r\n\r\nGiven the WG feedback so far, I think we'll need to discuss this here. If you'd rather do it in a separate PR, then feel free to just leave a TODO here.\r\n\r\n_Originally posted by @cjpatton in https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/4#discussion_r2114816776_\r\n            ",
      "createdAt": "2025-05-30T14:15:26Z",
      "updatedAt": "2025-06-13T13:34:08Z",
      "closedAt": "2025-06-13T13:34:08Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: The scope of this issue might change if (1) we decide to scope the draft to \"request bot auth\" (#3) and (2) we decide the draft itself should manage the complexity of authentication logic, e.g., by partitioning the set of trust anchors and spelling out requirements for CAs.",
          "createdAt": "2025-05-30T16:02:44Z",
          "updatedAt": "2025-05-30T16:02:44Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "I'm not sure it needs to manage partitioning a trust anchor set as is.  Assuming the client sends the extension and it \"means whatever we decide it means\" and the server replies with a certificate request message echoing the extension, The server is certainly free to tell the client what CA it expects for this via the CA extension, which would be the normal way servers do this today.  Chris do you see a need to change that? \n\nNow, of course, this could then end up with something the client can't satisfy, at which point we are back to sending an empty certificate reply, and the server gets to decide if it wants to proceed or not. \n",
          "createdAt": "2025-06-09T17:48:28Z",
          "updatedAt": "2025-06-09T17:48:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not sure it needs to manage partitioning a trust anchor set as is. Assuming the client sends the extension and it \"means whatever we decide it means\" and the server replies with a certificate request message echoing the extension, The server is certainly free to tell the client what CA it expects for this via the CA extension, which would be the normal way servers do this today. Chris do you see a need to change that?\n\nI don't think we need to change this logic, no. My concern has more to do with how the certificate is used to handle application data.\n\nSuppose for instance that the server is configured to always request a certificate so that, if the client presents a valid certificate, it gets access to certain HTTP resources (like `POST /admin/api` or something). If the server grants access if _any_ certificate is presented, then it might inadvertently grant access to a bot as well.  The server needs to modify its logic to grant access only if the right certificate is used.\n\nI don't think we necessarily need to deal with this at the protocol level, but it's worthy of a security consideration that helps implementers do the right thing.\n\n> Now, of course, this could then end up with something the client can't satisfy, at which point we are back to sending an empty certificate reply, and the server gets to decide if it wants to proceed or not.\n\nThat sounds right to me. Have you had a chance to look at the text since @jhoyla's last PR (#4)? I think that's more or less what the draft says now. Do you think this is the right client behavior?",
          "createdAt": "2025-06-09T18:14:24Z",
          "updatedAt": "2025-06-09T18:14:24Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "\"If the server grants access if any certificate is presented, then it might inadvertently grant access to a bot as well. The server needs to modify its logic to grant access only if the right certificate is used.\"\n\nI think this comes down to defining what \"bot auth\" means, and with that, writing an appropriate security considerations section indicating that implementors need to ensure that access is only granted to things appropriate for bot auth. This can also of course, include restricting things that would otherwise be accessible without a certificate if I was not a bot ;) \n\n",
          "createdAt": "2025-06-09T18:26:44Z",
          "updatedAt": "2025-06-09T18:27:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. To me the definition of bot auth is most relevant to (or even _only relevant to_?) how we treat application data. Namely, we treat the TLS client as if it were an unauthenticated TLS client, except the server might bypass some security measure applied to unauthenticated TLS clients. For instance, we want to rate limit clients _pretending_ to be GoogleBot, but not GoogleBot itself.\n\n@jhoyla has been thinking about this for a lot longer than me and perhaps has a more precise definition in mind!",
          "createdAt": "2025-06-09T18:44:39Z",
          "updatedAt": "2025-06-09T18:44:39Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "I don't think \"bypass\" is the correct framing here. They are going down an alternative, and IMO _stricter_ path. \n\nBut overall, I think we should say in the security considerations something along the lines of \"If the bot auth flag is accepted then the server should verify the certificate against an appropriate set of trust anchors, which may or may not be disjoint to the set of trust anchors it uses when the flag is ignored or rejected. Failure to do so may result in authenticating a bot when they are not intended to be authenticated.\"",
          "createdAt": "2025-06-10T15:27:48Z",
          "updatedAt": "2025-06-10T15:27:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think \"bypass\" is the correct framing here. They are going down an alternative, and IMO _stricter_ path.\n\nAgreed.\n\n> But overall, I think we should say in the security considerations something along the lines of \"If the bot auth flag is accepted then the server should verify the certificate against an appropriate set of trust anchors, which may or may not be disjoint to the set of trust anchors it uses when the flag is ignored or rejected. Failure to do so may result in authenticating a bot when they are not intended to be authenticated.\"\n\nI'm mostly on board with this, but I would want to recommend against mixing trust anchors (\"may not be disjoint\").",
          "createdAt": "2025-06-10T15:43:37Z",
          "updatedAt": "2025-06-10T15:43:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@bob-beck would you mind taking a look at the changes to Security Considerations in this PR: https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/15",
          "createdAt": "2025-06-11T18:49:31Z",
          "updatedAt": "2025-06-11T18:49:31Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOKjmGVs64_ezi",
      "title": "Compare to using HTTP Signatures for bot auth",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/7",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We're planning to use HTTP Signatures (RFC 9241) for bot authentication: https://github.com/thibmeu/http-message-signatures-directory. This might be inappropriate for some use cases or deployment scenarios. We should help readers decide whether request client auth is more appropriate.\n\nSpecifically, the draft should spell out the potential efficiency issues and security risks of using HTTP signatures for bot authentication and how these might be addressed with authentication at the TLS level.",
      "createdAt": "2025-05-30T16:09:24Z",
      "updatedAt": "2025-06-11T13:14:16Z",
      "closedAt": "2025-06-11T13:14:15Z",
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOKjmGVs64_fy8",
      "title": "Add reference to draft-meunier-web-bot-auth-architecture",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/8",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The motivation for this draft is primarily to solve the use cases described in https://datatracker.ietf.org/doc/draft-meunier-web-bot-auth-architecture/. We should add an informational reference to this to the intro.\n\nMore generally, we want to enumerate the use cases which this draft might solve for.",
      "createdAt": "2025-05-30T16:11:34Z",
      "updatedAt": "2025-06-11T13:14:15Z",
      "closedAt": "2025-06-11T13:14:15Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOKjmGVs64_nlH",
      "title": "Ensure the flag is safe to enable inadvertently",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/9",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "One concern discussed at IETF 123 is that non-bot clients might propose the flag inadvertently. This is in part a question about proper documentation, but we should also take seriously the question of how to make this safe.\n\nOnce we land #4, the protocol will be something like this: if the client proposes the flag and the server acknowledges it, then the server MUST send CertificateRequest with the acknowledgement.\n\nThe risk seems fairly minimal for this protocol, since the client now knows what code path the server has to selected (client auth with or without the flag). Still, we should play out what might go wrong on the client and side and how an implementation can ensure it does the right thing.",
      "createdAt": "2025-05-30T16:28:37Z",
      "updatedAt": "2025-06-19T18:39:36Z",
      "closedAt": "2025-06-19T18:39:36Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #21, which is more to the point.",
          "createdAt": "2025-06-19T18:39:36Z",
          "updatedAt": "2025-06-19T18:39:36Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOKjmGVs65374k",
      "title": "Compare to concealed auth for HTTP",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/10",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Could we use https://datatracker.ietf.org/doc/rfc9729/ to bind requests to the TLS channel? Does this work in practice for our main case of bot auth?",
      "createdAt": "2025-06-04T16:41:53Z",
      "updatedAt": "2025-06-11T13:14:15Z",
      "closedAt": "2025-06-11T13:14:15Z",
      "comments": [
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "We tried this initially, but it doesn't play nicely with connection pooling. We tried several different HTTP libraries, and we found that most require you to create a request and dispatch it to the connection pool, whereupon the pool decides which connection it will go on. In some libraries/scenarios the connection isn't even established until the request has been dispatched. This makes constructing the signature very difficult because you can't reliably get the appropriate TLS exporter. At small scale it's possible to manage in a few ways, i.e. not using connection pooling, using callbacks to modify the request after the connection has been selected, or sending dummy get requests with the appropriate header on every connection that gets added to the pool, but each of these has very significant drawbacks when you scale past a few connections. ",
          "createdAt": "2025-06-05T10:07:07Z",
          "updatedAt": "2025-06-05T10:07:07Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOKjmGVs662zJS",
      "title": "Operational Considerations: what are the constraints to consider when choosing how to authenticate bots?",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/12",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add an operational considerations section that justifies this mechanism from an operational perspective. We talk about this a bit in the new appendix in which we list alternatives (see #11), but we should also provide a list of considerations an implementer can take into account when picking between alternatives. Some ideas I've heard:\n\n1. It's much more efficient than HTTP Signatures for the same application (lower communication, less signing/verification)\n2. X.509 certificates gives the deployment a lot more control over key management \n\nAny other thoughts here @jhoyla and @thibmeu?",
      "createdAt": "2025-06-10T21:52:40Z",
      "updatedAt": "2025-06-13T10:49:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "thibmeu",
          "authorAssociation": "NONE",
          "body": "For 1., I'm not sure the number of signing/verification would be that high of an overhead. The current HTTP Message Sigs for bots draft has an open issue about the topic https://github.com/thibmeu/http-message-signatures-directory/issues/4, and could consider clearly mentioning headers compression mechanism as recommended.\n\nfor 2., JWK sets are different than certificates, but already benefit from a wide deployment as well. Keys _could_ be linked to certificates, as part of x5c/x5t field of JWK for instance. This needs more exploration, as mentioned in https://github.com/thibmeu/http-message-signatures-directory/issues/27.\n\nFor operational considerations, I would add:\n3. Ease of deployment. My initial impression is that TLS is a lower level primitive which tends to have controlled exposure in client/server implementations. I'm not sure what's the best term to convey this idea.\n\nIt'd also be great to identify what are the requirements for specific deployments/applications. For instance, a crawler may have a long running connection, while RAG would be more instantaneous. The overhead is likely different.\n\nIn the end, I think the alternative is for Bots/crawler. If two solutions are provided, origins will end up implementing both.",
          "createdAt": "2025-06-11T07:25:14Z",
          "updatedAt": "2025-06-11T07:25:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> For 1., I'm not sure the number of signing/verification would be that high of an overhead. The current HTTP Message Sigs for bots draft has an open issue about the topic [thibmeu/http-message-signatures-directory#4](https://github.com/thibmeu/http-message-signatures-directory/issues/4), and could consider clearly mentioning headers compression mechanism as recommended.\n\nHow would headers compression work? If you have to sign each request, then you also have to verify the signature for each request. At the TLS layer we verify just once.\n\nThat said, one could imagine the cost of signing/verifying each request is not really a problem for web bot auth.\n\n\n> For operational considerations, I would add: 3. Ease of deployment. My initial impression is that TLS is a lower level primitive which tends to have controlled exposure in client/server implementations. I'm not sure what's the best term to convey this idea.\n\nGood one to add. Though I'm not sure we can argue this mechanism would be easier to deploy in all situations. If an implementer has more control over the HTTP stack than their TLS stack, some sort of HTTP-based authentication mechanism might well be easier.\n\n\n> It'd also be great to identify what are the requirements for specific deployments/applications. For instance, a crawler may have a long running connection, while RAG would be more instantaneous. The overhead is likely different.\n\nyeah hopefully the web bot auth BoF will flesh this out a little :)\n\n",
          "createdAt": "2025-06-11T15:11:15Z",
          "updatedAt": "2025-06-11T15:11:15Z"
        },
        {
          "author": "thibmeu",
          "authorAssociation": "NONE",
          "body": "for header compression, I'm thinking of [RFC 7541 HPACK: Header Compression for HTTP/2](https://datatracker.ietf.org/doc/html/rfc7541). The current spec for HTTP Sigs for Bots does not sign request digest, it signs the @authority. This means you can reuse it if the @authority is unchanged and the origins is accepting reuse.",
          "createdAt": "2025-06-11T15:24:54Z",
          "updatedAt": "2025-06-11T15:24:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, interesting. I believe we were missing that detail, @jhoyla. (This also makes me even more nervous about replay attacks.)",
          "createdAt": "2025-06-11T18:56:00Z",
          "updatedAt": "2025-06-11T18:56:00Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "The overhead for signing/verification is effectively unbounded in the worst case. A connection that involves hundreds or even thousands of requests is going to see a much bigger difference than a connection that sends one request before being torn down.\n\n@cjpatton In HTTP-Signatures the server effectively controls the trade off of replays against efficiency. It can do anything from having a global strike registry to ensure no nonce was ever used before, to allowing tokens with short (or even very short) expiration times to be replayed, to doing no replay checking at all. It can also transition between these policies at a per connection or even a per request level. ",
          "createdAt": "2025-06-12T12:39:35Z",
          "updatedAt": "2025-06-12T12:39:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Very interesting. It would also be really nice if it could bind to the TLS session :)",
          "createdAt": "2025-06-12T13:17:35Z",
          "updatedAt": "2025-06-12T13:17:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "4. Proxies: HTTP sigs works in both the forward and reverse proxy case without any trouble. You might be able to make it work for request clien auth, but it depends. (Likewise for concealed auth.) cc @jhoyla ",
          "createdAt": "2025-06-12T14:48:14Z",
          "updatedAt": "2025-06-12T14:49:23Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "So `request_client_auth` is bound to a particular TLS connection, so can't be proxied. In the case of a reverse proxy, if the proxy has the private key for your website then you already trust it. It's probably reasonable for you to just trust the proxy to honestly report the client certs it sees. For forward proxies `request_client_auth` will only identify the forward proxy, which may be useful in some cases. This actually pairs well with HTTP Sigs. You could use HTTP Sigs to authenticate the principal (i.e. the machine behind the proxy) and `request_client_auth` to authenticate the proxy.",
          "createdAt": "2025-06-13T10:49:01Z",
          "updatedAt": "2025-06-13T10:49:01Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOKjmGVs67Lcr0",
      "title": "Don't refer to `request_client_auth` until it's defined",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/16",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "request_client_auth has not been introduced yet.\r\nthis may also be a reference to the specific definition section via `{#id}` and `{{id}}`\r\n\r\n```suggestion\r\nIn particular, `request_client_auth` flag, the TLS flag defined in this document, is not intended to be used by web\r\n```\r\n\r\n_Originally posted by @thibmeu in https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/15#discussion_r2141962444_\r\n            ",
      "createdAt": "2025-06-12T13:38:14Z",
      "updatedAt": "2025-06-12T13:38:14Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 17,
      "id": "I_kwDOKjmGVs67V6D_",
      "title": "Where should the server acknowledge the `req_client_auth` flag?",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/17",
      "state": "OPEN",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "There are three places where the server might plausibly acknowledge the flag. The server could acknowledge the flag either in `EncryptedExtensions` (EE), `Certificate` (CT), or in the `CertificateRequest` (CR) message. (There is no reason that the flag should be unencrypted, ruling out SH, HRR is not normally sent, and NST is sent too late.)\n\n# EncryptedExtensions\n\n(+) Putting the flag in the EE is where most flags are likely to be acknowledged. This means there is more likely to be overlap with other TLS Flags (meaning fewer bytes on the wire). \n(-) If the server acknowledges the flag, but chooses to resume the connection (or use an OOB PSK) then it's unclear what the client should do.\n(-) If the server acknowledges the flag but the doesn't send a `CertificateRequest` it's unclear what the client should do.\n\n# Certificate\n\n(+) Cannot be sent if the server resumes the connection (or uses an OOB PSK)\n(-) If the server acknowledges the flag but the doesn't send a `CertificateRequest` it's unclear what the client should do.\n\n# CertificateRequest\n\n(+) The server can only acknowledge the flag at the appropriate time.\n(-) Flags SHOULD be acknowledged in either the SH, EE, or CT messages.\n(-) The server can distinguish between clients that support the flag (but aren't offering it) and those that don't by inappropriately sending the `req_client_auth` flag in its CR message. Clients that support the flag will terminate the connection with an `illegal_parameter` alert, those that don't will ignore it.\n\n\nOne solution is to have the client ignore the flag if it's inappropriately set in the CR message, but this seems against the spirit of the draft.",
      "createdAt": "2025-06-13T10:23:27Z",
      "updatedAt": "2025-06-13T10:23:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOKjmGVs67YsOH",
      "title": "Security considerations: The difference between principals and agents",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/18",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "HTTP sigs is vulnerable to the following attack:\n* Web crawler makes request to CDN1\n* CDN1 replays request to CDN2\n\nWe know that TLS client auth is not vulnerable to the same attack. This might make `request_client_auth` better suited to some use cases.\n\nThe case we want to make is that HTTP sigs is better suited to authenticating the principal, but in the web bot auth use case, it's being used to authenticate the agent. TLS client auth is what you want if you need to authenticate the agent.\n\nThe task is to make this case in security considerations, with examples of principals and agents that motivate the real attacks.",
      "createdAt": "2025-06-13T14:43:21Z",
      "updatedAt": "2025-06-17T14:21:59Z",
      "closedAt": "2025-06-17T14:21:59Z",
      "comments": [
        {
          "author": "thibmeu",
          "authorAssociation": "NONE",
          "body": "You can quote [Section 5.6 of HTTP Sigs for Bots](https://datatracker.ietf.org/doc/html/draft-meunier-web-bot-auth-architecture#name-reverse-proxy-consideration) directly. This is called out in security considerations. If there are improvements to the wording, they could be useful for that draft.",
          "createdAt": "2025-06-13T15:32:24Z",
          "updatedAt": "2025-06-13T15:32:24Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Excellent, thanks for the reference!\n",
          "createdAt": "2025-06-13T15:38:35Z",
          "updatedAt": "2025-06-13T15:38:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "What convinced me that this framing makes sense is a connection to the following idea.\n\nMutually authenticated TLS has the nice property that it authenticates a single interaction between the bot and the server. This means that every message sent in that interaction could _only_ be sent in that interaction. \n\nHTTP sigs does not authenticate a single interaction, but possibly many. As a consequence, a message transmitted in one interaction can potentially be replayed in another.\n\nSo how does this idea of matching conversations connect to principals versus agents?\n\nTake the web crawler example. The agent is the actual crawler; the principal is the company building the index. For TLS client auth, the principal would be the CA and the agent would be a party presenting a client cert.\n\nPrincipals have many-to-one interactions with servers. In the web crawler case, the principal's CA cert is used to validate the agent's cert in each handshake.\n\nAgents have one-to-one interactions with servers. In the web crawler case, the agent presents a cert and uses it to sign the handshake.\n\nThe way we're hoping to use HTTP signatures for web bot auth is to authenticate the agent. But because of how the protocol works, we're not authenticating a one-to-one interaction; we're actually authenticating a many-to-one interaction. In other words, the messages sent in this protocol can be replayed to some extent in conversations among other entities in the protocol.\n\nNow, there are likely ways we can get the same property with an HTTP-based authentication mechanism. E.g., we can consider extending HTTP sigs to bind to the TLS session in some way. Of course, this has some downsides, like not being able to proxy signature.",
          "createdAt": "2025-06-13T16:09:12Z",
          "updatedAt": "2025-06-13T16:09:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #19.",
          "createdAt": "2025-06-17T14:21:59Z",
          "updatedAt": "2025-06-17T14:21:59Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOKjmGVs68aNfI",
      "title": "Explanation of client CertificateRequest handling behavior is misleading",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/20",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> The behaviour specified in [[RFC8446](https://jhoyla.github.io/draft-jhoyla-req-mtls-flag/draft-jhoyla-req-mtls-flag.html#RFC8446)] for a client that receives a CertificateRequest that it cannot satisfy is to send an empty Certificate message followed by a Finished message. However in practice many clients simply terminate the connection in anticipation of a \"certificate_required\" alert.\n>\n> This behaviour makes it difficult for servers to send CertificateRequest messages in the wild.\n\nThis text suggests that clients terminate the connection because they don't have a certificate. In fact, a web browser might exhibit the observed behavior because it _might_ be able to rustle up a certificate. In this case, the browser would terminate the connection (the observed behaviour), prompt the user to select a certificate, then retry the connection with the selected certificate.\n\nThis text is misleading because it implies a solution that doesn't solve the problem. See #21.",
      "createdAt": "2025-06-19T17:35:22Z",
      "updatedAt": "2025-06-19T19:51:39Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 21,
      "id": "I_kwDOKjmGVs68anmE",
      "title": "The client should indicate which PKI its certificate belongs to",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/21",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The server already has logic for deciding whether to send CertificateRequest (CR) and which CAs to include (if any), and the client already has logic for responding to a CR and selecting a certificate. Negotiating the `request_client_auth` needs to signal to the client and server to bypass all of this logic and do something else.\n\nThis touches a lot of complexity in client and server implementations that the draft hasn't sorted out. A couple of examples:\n\n1. Suppose the client is a bot and offers the flag, and the server requests a CR but doesn't know about web bot auth PKI. The result would be that the client offers a cert the server can't validate, and the server will abort. Ideally, the client would be able to detect the mismatch and send an empty Certificate message instead.\n2. Suppose the client is not a bot but offers the flag for some other use case, and the server acks the flag and knows about web bot auth. It needs some way of discerning what use the case the client's certificate is for so that it can handle application data accordingly.\n\nFrom offline discussions, there are a lot more nasty examples than these. The draft should avoid this complexity.\n\nOne way is to change the protocol such that the extension is only negotiated if the client indicates a PKI that the server knows about. There's a number ways to do this, for instance have the client indicate to the server in its extension request which CA the server should use.",
      "createdAt": "2025-06-19T18:39:04Z",
      "updatedAt": "2025-06-19T18:39:04Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOKjmGVs5dd2do",
      "title": "First draft",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/1",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-22T15:12:56Z",
      "updatedAt": "2023-10-22T15:13:24Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "c6a3ba36b4281cc3d98a5abab5ef7a39636d64e1",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "version00",
      "headRefOid": "100998bc6ee53c8397c8432560b141a513b86355",
      "closedAt": "2023-10-22T15:13:24Z",
      "mergedAt": "2023-10-22T15:13:24Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "b656c7b70cbed37b0719c914baeaaf5dff41810c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOKjmGVs5dh17m",
      "title": "First draft",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/2",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-23T13:12:07Z",
      "updatedAt": "2023-10-23T13:16:22Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "1610fe8ff3d1f07f59ea9ddfab986ec757382605",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "version00",
      "headRefOid": "1610fe8ff3d1f07f59ea9ddfab986ec757382605",
      "closedAt": "2023-10-23T13:16:17Z",
      "mergedAt": "2023-10-23T13:16:17Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "1610fe8ff3d1f07f59ea9ddfab986ec757382605"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "PR_kwDOKjmGVs6TcGtu",
      "title": "Client MUST send empty Certificate message",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/4",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Clients that receive `CertificateRequest`s in practice will terminate the connection in anticipation of a \"certificate_required\" alert, rather than sending an empty `Certificate` message, as specified in [RFC-8446, Section 4.4.2](https://www.rfc-editor.org/rfc/rfc8446#section-4.4.2).\r\nThis PR updates the draft to specify that the client MUST send an empty `Certificate` message, and SHOULD NOT terminate the connection in anticipation of a \"certificate_required\" alert.\r\nWe can't require a MUST NOT terminate the connection, as the client might want to terminate the connection for other, unrelated reasons.",
      "createdAt": "2025-04-22T13:20:28Z",
      "updatedAt": "2025-06-09T12:55:18Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "9885460cf74ddbd2ac1bfc70e21ddbc10ae797a7",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "jhoyla/empty-cert-message",
      "headRefOid": "3e5b34c7d8e072683cc328a359358b6eb043ddd0",
      "closedAt": "2025-06-09T12:55:18Z",
      "mergedAt": "2025-06-09T12:55:18Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "b197cbd30ee01853b1d1a176a0b56a1ab5b5575b"
      },
      "comments": [
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "Following comments from @davidben, this has been changed to require the server to echo the flag in the `CertificateRequest` message. This allows the client to determine _why_ the server requested a certificate.",
          "createdAt": "2025-05-27T16:59:21Z",
          "updatedAt": "2025-05-27T16:59:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKjmGVs6rLo26",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-27T17:27:50Z",
          "updatedAt": "2025-05-27T17:37:50Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "\r\n```suggestion\r\nextra round trip, and requires negotiation at the application layer.\r\n```",
              "createdAt": "2025-05-27T17:27:50Z",
              "updatedAt": "2025-05-27T17:37:50Z"
            },
            {
              "originalPosition": 76,
              "body": "It looks like the server can actually _offer_ TLS flags in CR: https://www.ietf.org/archive/id/draft-ietf-tls-tlsflags-15.html#section-3-4\r\n\r\nIn this case it might not be a good idea to ack the client's offer in CR as well.\r\n\r\nIn any case, I'm a little wary of this draft mandating where a server implementation chooses to acknowledge TLS Flags. The more flexible we can be, the less likely it is for this flag to complicate the implementation of other flags.",
              "createdAt": "2025-05-27T17:37:48Z",
              "updatedAt": "2025-05-27T17:37:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rUkDs",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-28T09:29:49Z",
          "updatedAt": "2025-05-28T09:29:49Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "So I do think we need to specify one place, because otherwise you need logic to handle what to do if the flags disagree. Say the `ServerHello` doesn't set the flag, `EncryptedExtensions` does, and `CertificateRequest` doesn't. Is it an error? Does it being set anywhere => set? \r\n\r\nThe server can offer TLS Flags in `CertificateRequest`, but we can define the `request_mtls` flag to only be valid if it was offered in the `ClientHello`.",
              "createdAt": "2025-05-28T09:29:49Z",
              "updatedAt": "2025-05-28T09:29:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rUowI",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-28T09:36:18Z",
          "updatedAt": "2025-05-28T09:36:19Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Added new language to that effect.",
              "createdAt": "2025-05-28T09:36:18Z",
              "updatedAt": "2025-05-28T09:36:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rdpnz",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-28T23:21:17Z",
          "updatedAt": "2025-05-28T23:21:17Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "I see. The TLS flags draft also requires us to specify which messages in which the flag may appear: https://datatracker.ietf.org/doc/html/draft-ietf-tls-tlsflags-15#section-4-4.3.1",
              "createdAt": "2025-05-28T23:21:17Z",
              "updatedAt": "2025-05-28T23:21:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rdrA-",
          "commit": {
            "abbreviatedOid": "03d2ea7"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-28T23:27:23Z",
          "updatedAt": "2025-05-28T23:51:07Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "How does the client handle the flag if it appears in a different message? Ideally the TLS Flags extension specifies the behavior in this case, but I'm not sure.",
              "createdAt": "2025-05-28T23:27:23Z",
              "updatedAt": "2025-05-28T23:51:07Z"
            },
            {
              "originalPosition": 79,
              "body": "Is this saying the server's acknowledgement (in the \"TLS Flags\" sense) is optional? If so, isn't the server's behavior here the same as if it doesn't implement the req mTLS flag?\r\n\r\nI think the phrase \"wishes to negotiate client authentication for another reason\" is throwing me. Am I right that you're just specifying behavior of servers that don't support this flag?\r\n",
              "createdAt": "2025-05-28T23:32:54Z",
              "updatedAt": "2025-05-28T23:51:07Z"
            },
            {
              "originalPosition": 83,
              "body": "The SHOULD NOT fills me with pause. As I understand it, the goal of this flag is to express to the server that the client will handle the CR in a specific way: respond with an (empty) CT. Is there a legitimate reason why a client might ignore this SHOULD NOT? ",
              "createdAt": "2025-05-28T23:48:03Z",
              "updatedAt": "2025-05-28T23:51:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rhT6e",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T09:15:38Z",
          "updatedAt": "2025-05-29T09:15:38Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "No I'm specifying the behaviour of a server that always asks for a client cert, irrespective of this flag (or possibly is asking for a client cert because of a different flag). If the server always asks for a cert, then the reason it's asking for a cert is _not_ the presence (or absence) of the flag.\r\n\r\nIt's important to specify this behaviour because if the server supports a different TLS Flag (say 82), and has support req mTLS but is not  configured to use it, it needs to know whether to set the flag or not.",
              "createdAt": "2025-05-29T09:15:38Z",
              "updatedAt": "2025-05-29T09:15:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rhYWJ",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T09:23:04Z",
          "updatedAt": "2025-05-29T09:23:04Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "IIUC the behaviour specified in the TLS Flags draft is a fatal `illegal_parameter` alert. \r\n> An endpoint that receives an unsolicited flag in another message (HRR, SH, EE, or CT) MUST generate a fatal illegal_parameter alert.\r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-tls-tlsflags-15#section-3-6\r\nI'll add text making this explicit.",
              "createdAt": "2025-05-29T09:23:04Z",
              "updatedAt": "2025-05-29T09:23:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rhbBn",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T09:27:53Z",
          "updatedAt": "2025-05-29T09:27:53Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Yes. If the server sets the `certificate_authorities` extension, and only lists authorities that the client doesn't support, ditto with `signature_algorithms`. Also, the client may wish to terminate the connection for another reason (e.g. server cert didn't verify), so we shouldn't require them to continue.",
              "createdAt": "2025-05-29T09:27:53Z",
              "updatedAt": "2025-05-29T09:27:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rhfjx",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T09:35:47Z",
          "updatedAt": "2025-05-29T09:35:47Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "This is specified on line 115:\r\n```diff\r\n-* Message shall be CH\r\n+* Message shall be CH, CR\r\n```\r\nStanding for `ClientHello` and `CertificateRequest` respectively.",
              "createdAt": "2025-05-29T09:35:47Z",
              "updatedAt": "2025-05-29T09:35:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rk0A7",
          "commit": {
            "abbreviatedOid": "18637e5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T14:42:41Z",
          "updatedAt": "2025-05-29T14:42:41Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Yes I see that . I would have resolved this thread but am unable to.",
              "createdAt": "2025-05-29T14:42:41Z",
              "updatedAt": "2025-05-29T14:42:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rpPSW",
          "commit": {
            "abbreviatedOid": "ea85945"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-29T22:02:45Z",
          "updatedAt": "2025-05-29T22:06:11Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "This is interesting because even if the flag on its own has no security impact, the use case we intend to support here -- web bot auth -- certainly does. Namely, we have to override the logic the server uses to decide whether to send a CertificateRequest, how to select a trust anchor to validate the Certificate, and how to handle application data. We don't want to authorize HTTP requests from a crawler that would otherwise require a different client identity.\r\n\r\nGiven the WG feedback so far, I think we'll need to discuss this here. If you'd rather do it in a separate PR, then feel free to just leave a TODO here.",
              "createdAt": "2025-05-29T22:02:45Z",
              "updatedAt": "2025-05-29T22:06:11Z"
            },
            {
              "originalPosition": 40,
              "body": "Along the lines of avoiding the term \"request mutual TLS\", we might rewrite this as\r\n```suggestion\r\nclient to prompt the server to request a certificate during the handshake. Sometimes a server does not want to authenticate every client, but\r\n```",
              "createdAt": "2025-05-29T22:03:50Z",
              "updatedAt": "2025-05-29T22:06:11Z"
            },
            {
              "originalPosition": 62,
              "body": "A bit nit-picky, but: what does \"directly available\" mean? A bot might still need to select a cert based on the contents of the CR.",
              "createdAt": "2025-05-29T22:05:58Z",
              "updatedAt": "2025-05-29T22:06:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rtPWa",
          "commit": {
            "abbreviatedOid": "ea85945"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-30T09:42:26Z",
          "updatedAt": "2025-05-30T09:42:26Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "The goal is to make it clear that you shouldn't set this flag if you aren't certain you have at least one certificate available. You don't want the client to start trying to enumerate keys on a smartcard or prompting the user for a PEM file. This is only supposed to be used if you already know what certificate(s) you have available.",
              "createdAt": "2025-05-30T09:42:26Z",
              "updatedAt": "2025-05-30T09:42:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rtRTZ",
          "commit": {
            "abbreviatedOid": "ea85945"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-30T09:45:28Z",
          "updatedAt": "2025-05-30T09:45:28Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Let's move that to a different PR. What I mean here is that, from a formal methods perspective, this flag is a no-op. The server is always allowed to send a `CertificateRequest`, set CAs, and handle application data in whatever way it likes without affecting the security of the TLS handshake.",
              "createdAt": "2025-05-30T09:45:28Z",
              "updatedAt": "2025-05-30T09:45:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rwDkU",
          "commit": {
            "abbreviatedOid": "ea85945"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-30T14:16:12Z",
          "updatedAt": "2025-05-30T14:16:12Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Filed https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/6.",
              "createdAt": "2025-05-30T14:16:12Z",
              "updatedAt": "2025-05-30T14:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6rwLYH",
          "commit": {
            "abbreviatedOid": "3e5b34c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't think this addresses everything, but it's a step in the right direction. I say we merge and iterate.",
          "createdAt": "2025-05-30T14:26:17Z",
          "updatedAt": "2025-05-30T14:26:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOKjmGVs6TcSiJ",
      "title": "Update workflows",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/5",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Update workflows to use correct / modern dependencies.",
      "createdAt": "2025-04-22T13:39:32Z",
      "updatedAt": "2025-04-22T13:40:29Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "1722581ff997d45dbc692a7f79f90a5f09879dfe",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "jhoyla/update-workflows",
      "headRefOid": "d498e46a30cbab46f2115ff38c9df8c707f37feb",
      "closedAt": "2025-04-22T13:40:29Z",
      "mergedAt": "2025-04-22T13:40:28Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "9885460cf74ddbd2ac1bfc70e21ddbc10ae797a7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOKjmGVs6ZsKKn",
      "title": "Add appendix",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/11",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Add appendix discussing alternative solutions.\r\n\r\nCloses #10.\r\nCloses #8.\r\nCloses #7.",
      "createdAt": "2025-06-09T13:55:58Z",
      "updatedAt": "2025-06-11T13:14:14Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "b197cbd30ee01853b1d1a176a0b56a1ab5b5575b",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "jhoyla/feedback",
      "headRefOid": "293e077b7f91bea8ce5b8f7e5f5843c882e65c64",
      "closedAt": "2025-06-11T13:14:14Z",
      "mergedAt": "2025-06-11T13:14:14Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "54a43355c9f4fca50046cc9aa3204c790bbd8f1c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKjmGVs6tfDjU",
          "commit": {
            "abbreviatedOid": "111f038"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Nice! I updated the top comment to reference the issues this PR closes.\r\n",
          "createdAt": "2025-06-09T16:29:28Z",
          "updatedAt": "2025-06-09T16:45:07Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Not a draft anymore ;)\r\n```suggestion\r\nConcealed Auth {{?RFC9729}} allows a client to attach a header\r\n```",
              "createdAt": "2025-06-09T16:29:28Z",
              "updatedAt": "2025-06-09T16:47:10Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nin some contexts, but in the case of authenticating bots may be difficult to\r\n```",
              "createdAt": "2025-06-09T16:30:04Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            },
            {
              "originalPosition": 14,
              "body": "Also, why would this be hard to implement specifically for the bots use case and not others?",
              "createdAt": "2025-06-09T16:32:38Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            },
            {
              "originalPosition": 27,
              "body": "We should mention the possibility of modifying the pooling code.\r\n```suggestion\r\n\r\nIt is possible to avoid this issue, for example by not using connection pooling, or modifying\r\nthe implementation so that the first request on each new connection includes the binding.\r\nIf modifying the implementation is not possible, then there are some ad-hoc options, such as\r\nsending a special \"pre-request\" on each connection that's added to a pool,\r\nhowever these solutions tend to be bespoke per library and bring a number of\r\ntheir own issues (e.g. handling servers that terminate connections after a\r\nsingle request, or handling resumption).\r\n```",
              "createdAt": "2025-06-09T16:38:35Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            },
            {
              "originalPosition": 35,
              "body": "Add a reference for these reservations.",
              "createdAt": "2025-06-09T16:39:38Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            },
            {
              "originalPosition": 41,
              "body": "Say why this is functionally equivalent. We might need to flesh out the proposal a bit more.",
              "createdAt": "2025-06-09T16:40:48Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            },
            {
              "originalPosition": 50,
              "body": "Mention the CDN use case specifically.",
              "createdAt": "2025-06-09T16:41:11Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            },
            {
              "originalPosition": 43,
              "body": "I would put this section first since this draft shares the same exact motivation as ours. I would also mention the shared motivation explicitly.",
              "createdAt": "2025-06-09T16:41:48Z",
              "updatedAt": "2025-06-09T16:45:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6tskeu",
          "commit": {
            "abbreviatedOid": "111f038"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-10T15:38:14Z",
          "updatedAt": "2025-06-10T15:38:14Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "So this is addressed in the next sentence.",
              "createdAt": "2025-06-10T15:38:14Z",
              "updatedAt": "2025-06-10T15:38:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6tsrwa",
          "commit": {
            "abbreviatedOid": "111f038"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-10T15:46:43Z",
          "updatedAt": "2025-06-10T15:46:43Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Do you mean this:\r\n\r\n> The way many HTTP libraries work is that they dispatch requests to a connection\r\npool. Once the request arrives at the pool it is sent on a chosen connection\r\ndriven by internal logic. This, unfortunately, makes it difficult to know which\r\nconnection a request will be sent on, and thus to produce the appropriate\r\nsignature.\r\n\r\nThis seems to be about any application that uses a connection pool. Are you suggesting that the use of connection pools is more common for bots than for non-bots?\r\n\r\nWhich reminds me of what we're discussing in https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/3#issuecomment-2959730400: how exactly are we defining bot? Does the definition of bot matter here?",
              "createdAt": "2025-06-10T15:46:43Z",
              "updatedAt": "2025-06-10T15:46:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6ttXVe",
          "commit": {
            "abbreviatedOid": "0473a96"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d \r\n",
          "createdAt": "2025-06-10T16:45:56Z",
          "updatedAt": "2025-06-10T19:18:56Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'm not sure it's correct to call it a bearer token. I think of a bearer token as just a shared secret.\r\n```suggestion\r\nmechanism for implementing HTTP authentication. This mechanism suffers from a number of drawbacks, notably that a new\r\n```",
              "createdAt": "2025-06-10T16:45:57Z",
              "updatedAt": "2025-06-10T19:18:56Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nin the multi-CDN (\"Content Distribution Network\") use case. If a bot creates a token for a realm that is provided\r\n```",
              "createdAt": "2025-06-10T19:14:07Z",
              "updatedAt": "2025-06-10T19:18:56Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\neach connection that's added to a pool. However these solutions tend to be\r\n```",
              "createdAt": "2025-06-10T19:15:22Z",
              "updatedAt": "2025-06-10T19:18:56Z"
            },
            {
              "originalPosition": 28,
              "body": "I don't see how the next paragraph is about bots specifically: see  but in the case of authenticating bots may be\r\ndifficult to implement.\r\n\r\n```suggestion\r\napplicable in some contexts, but may be\r\ndifficult to implement.\r\n```",
              "createdAt": "2025-06-10T19:17:22Z",
              "updatedAt": "2025-06-10T19:18:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6twSRC",
          "commit": {
            "abbreviatedOid": "0473a96"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-10T21:47:35Z",
          "updatedAt": "2025-06-10T21:47:36Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "nit: consistent title capitalization (or let me know if you're following a convention I'm aware of)\r\n```suggestion\r\n### Post-handshake Authentication (PHA)\r\n```",
              "createdAt": "2025-06-10T21:47:35Z",
              "updatedAt": "2025-06-10T21:47:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6twSVs",
          "commit": {
            "abbreviatedOid": "0473a96"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-10T21:47:48Z",
          "updatedAt": "2025-06-10T21:47:48Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "nit: same as above\r\n```suggestion\r\n### Client-Initiated Exported Authenticators\r\n```",
              "createdAt": "2025-06-10T21:47:48Z",
              "updatedAt": "2025-06-10T21:47:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t3hiq",
          "commit": {
            "abbreviatedOid": "0473a96"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T12:51:46Z",
          "updatedAt": "2025-06-11T12:51:46Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "A bearer token is anything that simple possession of grants access, i.e. they are always transferable. It doesn't need to involve a shared secret, it can be, for example a signed blob. ",
              "createdAt": "2025-06-11T12:51:46Z",
              "updatedAt": "2025-06-11T12:51:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOKjmGVs6aCabu",
      "title": "Mostly editorial",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/13",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Upon reading the draft I wanted to split up some of the bigger paragraphs into smaller ones. I also noticed that we use BCP 14 key words in the intro, before they're defined, and thought we should avoid this.",
      "createdAt": "2025-06-11T13:47:51Z",
      "updatedAt": "2025-06-11T18:39:05Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "54a43355c9f4fca50046cc9aa3204c790bbd8f1c",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "cjpatton/editorial",
      "headRefOid": "97db794a963bed16782c4ee64065216a40c3626f",
      "closedAt": "2025-06-11T18:39:05Z",
      "mergedAt": "2025-06-11T18:39:05Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ec68e0573e57f8f06f14328a0bddebea0267f1ff"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKjmGVs6t6-bp",
          "commit": {
            "abbreviatedOid": "631d3a5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T16:22:33Z",
          "updatedAt": "2025-06-11T16:24:05Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Why make this non-normative?",
              "createdAt": "2025-06-11T16:22:33Z",
              "updatedAt": "2025-06-11T16:24:05Z"
            },
            {
              "originalPosition": 23,
              "body": "I def. think this is a hard requirement.",
              "createdAt": "2025-06-11T16:23:06Z",
              "updatedAt": "2025-06-11T16:24:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7Eh4",
          "commit": {
            "abbreviatedOid": "631d3a5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T16:31:55Z",
          "updatedAt": "2025-06-11T16:31:55Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "because this is section 1 and  we don't introduced the BCP 14 key words until section 2",
              "createdAt": "2025-06-11T16:31:55Z",
              "updatedAt": "2025-06-11T16:31:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7HPq",
          "commit": {
            "abbreviatedOid": "631d3a5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T16:35:17Z",
          "updatedAt": "2025-06-11T16:35:17Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I don't have an issue with this being normative, my point is that editorially it doesn't make sense to have normative text here.",
              "createdAt": "2025-06-11T16:35:17Z",
              "updatedAt": "2025-06-11T16:35:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7bnP",
          "commit": {
            "abbreviatedOid": "631d3a5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T17:04:11Z",
          "updatedAt": "2025-06-11T17:04:11Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Ah ok, could you possibly put the normative language in later on then?",
              "createdAt": "2025-06-11T17:04:11Z",
              "updatedAt": "2025-06-11T17:04:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7bv7",
          "commit": {
            "abbreviatedOid": "631d3a5"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-11T17:04:22Z",
          "updatedAt": "2025-06-11T17:04:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKjmGVs6t8e0v",
          "commit": {
            "abbreviatedOid": "631d3a5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T18:38:32Z",
          "updatedAt": "2025-06-11T18:38:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Done.",
              "createdAt": "2025-06-11T18:38:32Z",
              "updatedAt": "2025-06-11T18:38:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOKjmGVs6aCcq1",
      "title": "Rename to req_bot_auth.",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/14",
      "state": "CLOSED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-11T13:50:41Z",
      "updatedAt": "2025-06-19T18:50:50Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "54a43355c9f4fca50046cc9aa3204c790bbd8f1c",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "jhoyla/rename",
      "headRefOid": "3754c89ee7f06eb9509e9e1b0d0f5e147def3ae8",
      "closedAt": "2025-06-19T18:50:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "thibmeu",
          "authorAssociation": "NONE",
          "body": "following the comment on #15: should this be `req_bot_auth` or `request_client_auth`?",
          "createdAt": "2025-06-12T08:57:10Z",
          "updatedAt": "2025-06-12T08:57:10Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "body": "I don't think we've reached a consensus on which we should go with. There's a fairly long discussion in Issue #3.",
          "createdAt": "2025-06-12T09:39:26Z",
          "updatedAt": "2025-06-12T09:39:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Just renaming the flag isn't going to get us where we want to go, so I'm going to close this.",
          "createdAt": "2025-06-19T18:50:49Z",
          "updatedAt": "2025-06-19T18:50:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKjmGVs6t4-RH",
          "commit": {
            "abbreviatedOid": "3754c89"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I've put up a #15 that might be a more appropriate first step. Would you mind taking a look?",
          "createdAt": "2025-06-11T14:06:42Z",
          "updatedAt": "2025-06-11T14:51:01Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I like the abstract as is. Perhaps just tack on a sentence that says something like \"the primary use case for this mechanism is ...\"",
              "createdAt": "2025-06-11T14:06:42Z",
              "updatedAt": "2025-06-11T14:51:01Z"
            },
            {
              "originalPosition": 31,
              "body": "Can we try to keep lines wrapped at 80 columns?",
              "createdAt": "2025-06-11T14:07:09Z",
              "updatedAt": "2025-06-11T14:51:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOKjmGVs6aDGYs",
      "title": "Address the possibility of the flag introducing authentication bugs in implementations",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/15",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #3. Describe web bot auth as our primary use case, but still allow for the possibility of using the flag for different use cases. The main purpose of this text is to scope the draft's security considerations to web bot auth.\r\n\r\nCloses #6 by recommending use of a separate set of trust anchors with this extension, which seems easy to enforce for our use case.",
      "createdAt": "2025-06-11T14:43:22Z",
      "updatedAt": "2025-06-13T21:57:08Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "ec68e0573e57f8f06f14328a0bddebea0267f1ff",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "cjpatton/6",
      "headRefOid": "e454a9bd48be373f9c11c03a9edd5e108f1016e4",
      "closedAt": "2025-06-13T13:34:07Z",
      "mergedAt": "2025-06-13T13:34:07Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "acd2ff65c23f1a1822c21935d8de7373ab64bb80"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Changed base.",
          "createdAt": "2025-06-11T18:40:47Z",
          "updatedAt": "2025-06-11T18:40:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed a couple of typos.",
          "createdAt": "2025-06-11T18:48:57Z",
          "updatedAt": "2025-06-11T18:48:57Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Tweaked the security considerations to match #14 per offline discussion with @jhoyla",
          "createdAt": "2025-06-12T15:25:46Z",
          "updatedAt": "2025-06-12T15:25:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@jhoyla coments",
          "createdAt": "2025-06-12T19:08:49Z",
          "updatedAt": "2025-06-12T19:08:49Z"
        },
        {
          "author": "bob-beck",
          "authorAssociation": "NONE",
          "body": "Belatedly mostly looks fine to me, can probably bikeshed some more but let's let others have a kick at the bikeshedding cat ;) ",
          "createdAt": "2025-06-13T21:07:06Z",
          "updatedAt": "2025-06-13T21:07:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Belatedly mostly looks fine to me, can probably bikeshed some more but let's let others have a kick at the bikeshedding cat ;)\r\n\r\nWe're happy to take belated feedback! Sorry we merged before you had a chance ... we weren't sure whether you'd have time to review or not.",
          "createdAt": "2025-06-13T21:57:08Z",
          "updatedAt": "2025-06-13T21:57:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKjmGVs6t7AJ2",
          "commit": {
            "abbreviatedOid": "062efa8"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T16:25:10Z",
          "updatedAt": "2025-06-11T16:31:40Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Based on the feedback we've had, I think we'll only get rough consensus if we restrict this to only the bot use case.",
              "createdAt": "2025-06-11T16:25:10Z",
              "updatedAt": "2025-06-11T16:31:40Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nspoofed {{?I-D.draft-meunier-web-bot-auth-architecture}}.\r\n```\r\nIt's not specifically network attackers?",
              "createdAt": "2025-06-11T16:29:34Z",
              "updatedAt": "2025-06-11T16:31:40Z"
            },
            {
              "originalPosition": 75,
              "body": "```suggestion\r\nchanges to how the client selects a certificate and how the server\r\n```\r\nIt doesn't change _how_ the server validates does it? Only what it validates against?",
              "createdAt": "2025-06-11T16:31:24Z",
              "updatedAt": "2025-06-11T16:31:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7NaQ",
          "commit": {
            "abbreviatedOid": "2c38ffa"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T16:43:13Z",
          "updatedAt": "2025-06-11T16:44:05Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "That's what I mean. Changed to \"which trust anchor the server uses to validate it.\"",
              "createdAt": "2025-06-11T16:43:13Z",
              "updatedAt": "2025-06-11T16:44:05Z"
            },
            {
              "originalPosition": 15,
              "body": "Agreed, but my intention was to leave that to a future to address. That is,this PR merely partially addresses #3, but doesn't close it.",
              "createdAt": "2025-06-11T16:44:01Z",
              "updatedAt": "2025-06-11T16:44:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7eD0",
          "commit": {
            "abbreviatedOid": "a1a89a2"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-11T17:06:47Z",
          "updatedAt": "2025-06-11T17:06:47Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "```suggestion\r\ncertificate to grant certain clients access to some resource, the server must take\r\n```",
              "createdAt": "2025-06-11T17:06:47Z",
              "updatedAt": "2025-06-11T17:06:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6t7eSV",
          "commit": {
            "abbreviatedOid": "a1a89a2"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-11T17:06:59Z",
          "updatedAt": "2025-06-11T17:06:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKjmGVs6uChhF",
          "commit": {
            "abbreviatedOid": "ffd7736"
          },
          "author": "thibmeu",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-12T07:37:59Z",
          "updatedAt": "2025-06-12T07:53:37Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "why \"web\" servers?\r\n\r\n```suggestion\r\nThis mechanism is primarily intended to allow servers to cryptographically\r\n```",
              "createdAt": "2025-06-12T07:37:59Z",
              "updatedAt": "2025-06-12T07:53:37Z"
            },
            {
              "originalPosition": 29,
              "body": "slightly changing the wording to make it clear we want to identify each crawler individually, and distinguish them from human users\r\n\r\n```suggestion\r\nof traffic so that they can be distinguished between one another, as well as from human users. This dynamic creates an incentive for attackers\r\n```",
              "createdAt": "2025-06-12T07:42:02Z",
              "updatedAt": "2025-06-12T07:53:37Z"
            },
            {
              "originalPosition": 35,
              "body": "clearly mentioning the assumption that crawlers leverage a TLS client\r\n\r\n```suggestion\r\nReaching the server normally requires first establishing a TLS {{?RFC8446}} connection with it.\r\nAuthentication of the TLS client is sufficient to thwart impersonation attacks, and\r\n```",
              "createdAt": "2025-06-12T07:44:28Z",
              "updatedAt": "2025-06-12T13:34:37Z"
            },
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nThe mechanism specified in this document could be applied to use cases beyond crawler identification.\r\n```",
              "createdAt": "2025-06-12T07:45:15Z",
              "updatedAt": "2025-06-12T07:53:37Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nHowever, doing so may entail security, privacy, or operational considerations that\r\n```",
              "createdAt": "2025-06-12T07:45:31Z",
              "updatedAt": "2025-06-12T07:53:37Z"
            },
            {
              "originalPosition": 45,
              "body": "request_client_auth has not been introduced yet.\r\nthis may also be a reference to the specific definition section via `{#id}` and `{{id}}`\r\n\r\n```suggestion\r\nIn particular, `request_client_auth` flag, the TLS flag defined in this document, is not intended to be used by web\r\n```",
              "createdAt": "2025-06-12T07:47:56Z",
              "updatedAt": "2025-06-12T07:53:37Z"
            },
            {
              "originalPosition": 79,
              "body": "```suggestion\r\nFor the identifying web crawlers use case mentioned in {{introduction}}, a web server\r\n```",
              "createdAt": "2025-06-12T07:48:46Z",
              "updatedAt": "2025-06-12T07:53:37Z"
            },
            {
              "originalPosition": 79,
              "body": "also: you should likely define `{#introduction}`",
              "createdAt": "2025-06-12T07:49:14Z",
              "updatedAt": "2025-06-12T07:53:37Z"
            },
            {
              "originalPosition": 87,
              "body": "not sure this is the right action. my understanding is if a server accepts the flag but does not verify the certificate, there's a high change of misimplementation, and we should recommend to terminate the connection\r\n\r\n```suggestion\r\ntrust anchors it uses when the flag is ignored or rejected. If it does\r\nnot, it is RECOMMENDED to terminate the connection.\r\n```",
              "createdAt": "2025-06-12T07:51:46Z",
              "updatedAt": "2025-06-12T07:53:37Z"
            },
            {
              "originalPosition": 56,
              "body": "would it be relevant to point to security consideration section of TLS flags ? https://datatracker.ietf.org/doc/html/draft-ietf-tls-tlsflags-15#name-security-considerations",
              "createdAt": "2025-06-12T07:53:34Z",
              "updatedAt": "2025-06-12T07:53:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uD7Xc",
          "commit": {
            "abbreviatedOid": "ffd7736"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-12T09:28:02Z",
          "updatedAt": "2025-06-12T09:28:02Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "So this passage isn't describing what to do if the server can't validate the certificate. This is saying that no certificate should chain up to the both the bot auth CA and the default CA. We should tighten up this language to be clearer. \r\n\r\nW.r.t. your other point one feature of TLS client auth is that if the server doesn't like the certificate then it can silently fallback to a unilaterally authed state. We should preserve that behaviour because that's what's \"expected\".",
              "createdAt": "2025-06-12T09:28:02Z",
              "updatedAt": "2025-06-12T09:28:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uEFpd",
          "commit": {
            "abbreviatedOid": "ffd7736"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-12T09:36:07Z",
          "updatedAt": "2025-06-12T09:36:07Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "So the security considerations in the TLS Flags draft apply only to flags acknowledged in `ServerHello` and `HelloRetryRequest`, so don't apply. I was thinking about including a reference to [Section 3](https://datatracker.ietf.org/doc/html/draft-ietf-tls-tlsflags-15#section-3-6) but that doesn't directly apply either, because it assumes flags are only acknowledged in \"HRR, SH, EE, or CT\". I could link the later requirement that invalid flags should terminate the connection, but that feels a bit forced.",
              "createdAt": "2025-06-12T09:36:07Z",
              "updatedAt": "2025-06-12T09:36:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uEH-S",
          "commit": {
            "abbreviatedOid": "ffd7736"
          },
          "author": "thibmeu",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-12T09:39:22Z",
          "updatedAt": "2025-06-12T09:39:23Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "would it make sense to update the wording ofn tls flag draft then?",
              "createdAt": "2025-06-12T09:39:22Z",
              "updatedAt": "2025-06-12T09:39:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uEfjK",
          "commit": {
            "abbreviatedOid": "ffd7736"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-12T10:11:20Z",
          "updatedAt": "2025-06-12T10:11:20Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "I don't think so? It's not a mistake there, because you can in general send unacknowledged flags in the CR, this flag just has special semantics due to it's structure.",
              "createdAt": "2025-06-12T10:11:20Z",
              "updatedAt": "2025-06-12T10:11:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uEgJD",
          "commit": {
            "abbreviatedOid": "ffd7736"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-12T10:12:16Z",
          "updatedAt": "2025-06-12T10:12:16Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Although now I think on it, maybe we should just say \"ignore\" because otherwise we're giving servers a way to detect whether a client understands this draft. A client that ignores the incorrect flag doesn't, one that aborts does. ",
              "createdAt": "2025-06-12T10:12:16Z",
              "updatedAt": "2025-06-12T10:12:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uHWXy",
          "commit": {
            "abbreviatedOid": "83e92b2"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks guys, I've force-pushed updates to please take a look at the diff since then.",
          "createdAt": "2025-06-12T13:29:59Z",
          "updatedAt": "2025-06-12T13:49:22Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "You're right, I don't think we need to be this specific.",
              "createdAt": "2025-06-12T13:29:59Z",
              "updatedAt": "2025-06-12T13:49:22Z"
            },
            {
              "originalPosition": 35,
              "body": "I don't think we need to talk specifically about web crawlers. We're also trying to leave room for other types of vaguely defined \"bots\" (though without using the word \"bot\"). I tweaked your suggestion in a way that I think works.",
              "createdAt": "2025-06-12T13:33:39Z",
              "updatedAt": "2025-06-12T13:49:22Z"
            },
            {
              "originalPosition": 41,
              "body": "We don't want to specialize this text to to crawlers (yet).",
              "createdAt": "2025-06-12T13:35:31Z",
              "updatedAt": "2025-06-12T13:49:22Z"
            },
            {
              "originalPosition": 42,
              "body": "Ah, that is niccer gramatically. I'll take this and part of the suggestion above.",
              "createdAt": "2025-06-12T13:36:11Z",
              "updatedAt": "2025-06-12T13:49:22Z"
            },
            {
              "originalPosition": 45,
              "body": "Good call out, but actually it's used in the second paragraph of the intro. I think your argument applies there as well, so let me file this as an editorial issue.",
              "createdAt": "2025-06-12T13:37:55Z",
              "updatedAt": "2025-06-12T13:49:22Z"
            },
            {
              "originalPosition": 45,
              "body": "See https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/issues/16.",
              "createdAt": "2025-06-12T13:39:04Z",
              "updatedAt": "2025-06-12T13:49:22Z"
            },
            {
              "originalPosition": 56,
              "body": "@jhoyla can you create an issue to track this?",
              "createdAt": "2025-06-12T13:42:57Z",
              "updatedAt": "2025-06-12T13:49:22Z"
            },
            {
              "originalPosition": 79,
              "body": "I'm not a fan of this wording, but it's a good idea to make an explicit label. Done.",
              "createdAt": "2025-06-12T13:43:55Z",
              "updatedAt": "2025-06-12T13:49:22Z"
            },
            {
              "originalPosition": 87,
              "body": "Added @jhoyla's suggestion for tightening the language, PTAL.",
              "createdAt": "2025-06-12T13:48:13Z",
              "updatedAt": "2025-06-12T13:49:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uKI1C",
          "commit": {
            "abbreviatedOid": "562266a"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-12T16:26:32Z",
          "updatedAt": "2025-06-12T16:32:48Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Please put normative SHOULD and MUST NOT for these later in the draft.",
              "createdAt": "2025-06-12T16:26:33Z",
              "updatedAt": "2025-06-12T16:32:48Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nof traffic so that the server can distinguish between them, as well as differentiate them\r\n```",
              "createdAt": "2025-06-12T16:30:39Z",
              "updatedAt": "2025-06-12T16:32:48Z"
            },
            {
              "originalPosition": 47,
              "body": "Please could you add an anchor to the Alternative Approaches section?",
              "createdAt": "2025-06-12T16:32:40Z",
              "updatedAt": "2025-06-12T16:32:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uLfOk",
          "commit": {
            "abbreviatedOid": "ce15b1c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-12T18:41:26Z",
          "updatedAt": "2025-06-12T18:42:46Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2025-06-12T18:41:26Z",
              "updatedAt": "2025-06-12T18:42:46Z"
            },
            {
              "originalPosition": 57,
              "body": "Done, in the previous change: https://jhoyla.github.io/draft-jhoyla-req-mtls-flag/draft-jhoyla-req-mtls-flag.html#section-3-4",
              "createdAt": "2025-06-12T18:41:49Z",
              "updatedAt": "2025-06-12T18:42:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 19,
      "id": "PR_kwDOKjmGVs6as232",
      "title": "Add text on principals and agents",
      "url": "https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/19",
      "state": "MERGED",
      "author": "jhoyla",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This text addresses Issue #18.",
      "createdAt": "2025-06-16T11:43:38Z",
      "updatedAt": "2025-06-17T13:21:21Z",
      "baseRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "baseRefName": "main",
      "baseRefOid": "acd2ff65c23f1a1822c21935d8de7373ab64bb80",
      "headRepository": "jhoyla/draft-jhoyla-req-mtls-flag",
      "headRefName": "jhoyla/principals-and-agents",
      "headRefOid": "e306acc7f658a3fae9098ee124319488ca443854",
      "closedAt": "2025-06-17T13:21:21Z",
      "mergedAt": "2025-06-17T13:21:21Z",
      "mergedBy": "jhoyla",
      "mergeCommit": {
        "oid": "881827b60d158039f0a922fde92cde76a1ca3010"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKjmGVs6uxEM5",
          "commit": {
            "abbreviatedOid": "a1aa1c6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Nice. Just some nits and an idea for framing the text.",
          "createdAt": "2025-06-16T13:16:37Z",
          "updatedAt": "2025-06-16T13:31:06Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Give an example of a concrete attack here, e.g. cut-and-paste the multi-CDN example from the alternative-appraoches section.",
              "createdAt": "2025-06-16T13:16:37Z",
              "updatedAt": "2025-06-16T13:31:06Z"
            },
            {
              "originalPosition": 20,
              "body": "\"from agent to agent\": What do you mean here? Can you give an example?",
              "createdAt": "2025-06-16T13:22:44Z",
              "updatedAt": "2025-06-16T13:31:06Z"
            },
            {
              "originalPosition": 4,
              "body": "Not a great title IMO, as \"principal\" and \"agent\" aren't' defined yet.\r\n\r\nI actually had something else in mind for this text. Tell me what you think about this. I think we have two main goals, the first to describe the intended security properties of request client auth, and the second to point out the shortcomings of HTTP signatures. (The answer of course is that HTTP sigs authenticates the principal, not the agent!)\r\n\r\nTherefore I think this text should be the _start_ of the security considerations section. The current text, which gets into considerations for deploying the mechanism, could go in its own subsection. WDYT?\r\n\r\n```suggestion\r\n## Principals vs Agents\r\n```",
              "createdAt": "2025-06-16T13:27:24Z",
              "updatedAt": "2025-06-16T13:31:06Z"
            },
            {
              "originalPosition": 25,
              "body": "Why would someone want to pass \"it\" on? Is this the reverse/forward proxy case?\r\n\r\nbit: Also, what is \"it\"? \"authentication of the agent\"?",
              "createdAt": "2025-06-16T13:29:05Z",
              "updatedAt": "2025-06-16T13:31:06Z"
            },
            {
              "originalPosition": 26,
              "body": "\"entire chain of actors\": for example? I'm wary about introducing too many hypotheticals.\r\n\r\nnit: If by \"actor\" you mean \"agent\", then let's say \"agent\" to avoid using too many words for the same thing.\r\n\r\n",
              "createdAt": "2025-06-16T13:30:08Z",
              "updatedAt": "2025-06-16T13:31:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uyJbQ",
          "commit": {
            "abbreviatedOid": "3c2e2c6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T14:29:17Z",
          "updatedAt": "2025-06-16T14:37:16Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "nit: extraneous change\r\n```suggestion\r\n```",
              "createdAt": "2025-06-16T14:29:17Z",
              "updatedAt": "2025-06-16T14:37:16Z"
            },
            {
              "originalPosition": 9,
              "body": "let's add an informative reference for \"matching sessions property of TLS\"? https://eprint.iacr.org/2020/1044 comes to mind, but pick your favorite :)",
              "createdAt": "2025-06-16T14:30:45Z",
              "updatedAt": "2025-06-16T14:37:16Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nintentional, as it easy to implement in the presence of an HTTP proxy.\r\n```",
              "createdAt": "2025-06-16T14:32:57Z",
              "updatedAt": "2025-06-16T14:37:16Z"
            },
            {
              "originalPosition": 21,
              "body": "Do we have an informative reference for \"principal\" versus \"agent\" authentication?:",
              "createdAt": "2025-06-16T14:33:36Z",
              "updatedAt": "2025-06-16T14:37:16Z"
            },
            {
              "originalPosition": 27,
              "body": "I still think the concept of \"immediate neighbors\" is a little vague. ",
              "createdAt": "2025-06-16T14:34:24Z",
              "updatedAt": "2025-06-16T14:37:16Z"
            },
            {
              "originalPosition": 11,
              "body": "Is this the first reference to HTTP signatures? If so, add a reference to @thibmeu's draft here.",
              "createdAt": "2025-06-16T14:34:46Z",
              "updatedAt": "2025-06-16T14:37:16Z"
            },
            {
              "originalPosition": 32,
              "body": "\"chain of agents\": see https://github.com/jhoyla/draft-jhoyla-req-mtls-flag/pull/19#discussion_r2150017380",
              "createdAt": "2025-06-16T14:36:01Z",
              "updatedAt": "2025-06-16T14:37:16Z"
            },
            {
              "originalPosition": 37,
              "body": "We need to explain who is the principal and who is the agent ini TLS client auth.\r\n\r\nAlso, nit: don't shorten authentication to auth\r\n```suggestion\r\nothers only one. TLS client authentication provides agent authentication and HTTP\r\nSignatures provide principal authentication. It is possible for both protocols\r\n```",
              "createdAt": "2025-06-16T14:37:00Z",
              "updatedAt": "2025-06-16T14:37:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uyT-j",
          "commit": {
            "abbreviatedOid": "3c2e2c6"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T14:40:35Z",
          "updatedAt": "2025-06-16T14:40:35Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This changes the meaning. The point is specifically contrasting the fact that it is possible to use HTTP Sigs in the presence of a proxy, but that it is not possible in the case of client auth. The ease of implementation is a red herring.",
              "createdAt": "2025-06-16T14:40:35Z",
              "updatedAt": "2025-06-16T14:40:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uyVHC",
          "commit": {
            "abbreviatedOid": "3c2e2c6"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T14:41:21Z",
          "updatedAt": "2025-06-16T14:41:21Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "No, although it would be great to find one. I've found a few other projects that use the word principal, but none that use it in precisely this sense.",
              "createdAt": "2025-06-16T14:41:21Z",
              "updatedAt": "2025-06-16T14:41:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uyW7k",
          "commit": {
            "abbreviatedOid": "3c2e2c6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T14:43:15Z",
          "updatedAt": "2025-06-16T14:43:15Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "SGTM. Based on our conversation last Friday (or Thursday?) I thought you wanted to leave open the possibility of request client auth being useful even if there's a proxy. I read this as \"if you have an HTTP proxy in the middle, then you're gonna have a bad time\", but I suppose that's a misreading too.",
              "createdAt": "2025-06-16T14:43:15Z",
              "updatedAt": "2025-06-16T14:43:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uyXXK",
          "commit": {
            "abbreviatedOid": "3c2e2c6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T14:43:46Z",
          "updatedAt": "2025-06-16T14:43:46Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Ack, that's a bummer.",
              "createdAt": "2025-06-16T14:43:46Z",
              "updatedAt": "2025-06-16T14:43:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uybah",
          "commit": {
            "abbreviatedOid": "3c2e2c6"
          },
          "author": "jhoyla",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T14:48:37Z",
          "updatedAt": "2025-06-16T14:48:38Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "So client auth can be useful in the presence of a proxy, but relies on the origin trusting the proxy. This is probably true in the case of a reverse proxy, given that they control your private key, but not necessarily.",
              "createdAt": "2025-06-16T14:48:37Z",
              "updatedAt": "2025-06-16T14:48:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6uyppn",
          "commit": {
            "abbreviatedOid": "674bba8"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "\ud83e\udd86 - let's hold off on merging until @thibmeu's had a chance to review.",
          "createdAt": "2025-06-16T15:01:14Z",
          "updatedAt": "2025-06-16T15:03:57Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "This would render as \"Section Section XXX\".\r\n```suggestion\r\nwith replays, see {{http-sigs}}.\r\n```",
              "createdAt": "2025-06-16T15:01:14Z",
              "updatedAt": "2025-06-16T15:03:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6u5g60",
          "commit": {
            "abbreviatedOid": "bbc35fe"
          },
          "author": "thibmeu",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Looks ok",
          "createdAt": "2025-06-17T06:35:53Z",
          "updatedAt": "2025-06-17T06:43:15Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "i really like this section an framing\r\nif you're willing, it would make for a great addition to the glossary and the related consideration discussed https://github.com/thibmeu/draft-meunier-glossary-somehow/issues/5",
              "createdAt": "2025-06-17T06:35:53Z",
              "updatedAt": "2025-06-17T06:43:15Z"
            },
            {
              "originalPosition": 48,
              "body": "probably worth mentioning [RFC 8473 Token Binding over HTTP](https://datatracker.ietf.org/doc/html/rfc8473)",
              "createdAt": "2025-06-17T06:41:36Z",
              "updatedAt": "2025-06-17T06:43:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKjmGVs6u-eUG",
          "commit": {
            "abbreviatedOid": "d17b162"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-17T13:09:12Z",
          "updatedAt": "2025-06-17T13:09:12Z",
          "comments": []
        }
      ]
    }
  ]
}